// src/services/ai/response/ResponseGenerator.js

/**
 * Klasa generujƒÖca odpowiedzi na podstawie wynik√≥w zapyta≈Ñ
 * Formatuje dane w czytelny spos√≥b dla u≈ºytkownika
 */
export class ResponseGenerator {

  /**
   * Szablony odpowiedzi dla r√≥≈ºnych typ√≥w zapyta≈Ñ
   */
  static templates = {
    // Receptury
    recipe_count: {
      simple: "W systemie znajduje siƒô **{count} receptur**.",
      withDetails: "W systemie znajduje siƒô **{count} receptur**.\n\nüìä **Szczeg√≥≈Çy:**\n{details}"
    },

    recipe_count_by_weight: {
      simple: "Znaleziono **{count} receptur** spe≈ÇniajƒÖcych kryteria wagowe.",
      withFilter: "Znaleziono **{count} receptur** z {totalRecipes} ca≈Çkowitej liczby, kt√≥rych suma sk≈Çadnik√≥w {filterDescription}.\n\nüìã **Przyk≈Çady receptur:**\n{examples}",
      detailed: "üîç **Analiza receptur wed≈Çug wagi sk≈Çadnik√≥w**\n\nZnaleziono **{count} receptur** z {totalRecipes} ca≈Çkowitej liczby, kt√≥re spe≈ÇniajƒÖ kryteria: {filterDescription}\n\nüìã **Lista receptur:**\n{recipesList}\n\nüìä **Statystyki:**\n{stats}"
    },

    recipe_count_by_ingredients: {
      withFilter: "Znaleziono **{count} receptur** z {totalRecipes} ca≈Çkowitej liczby, kt√≥re majƒÖ {filterDescription}.\n\nüìã **Przyk≈Çady receptur:**\n{examples}"
    },

    recipe_weight_analysis: {
      detailed: "üìä **Analiza wag receptur**\n\nüî¢ **Statystyki og√≥lne:**\n‚Ä¢ ≈ÅƒÖczna liczba receptur: **{totalRecipes}**\n‚Ä¢ ≈örednia waga receptury: **{averageWeight}g**\n‚Ä¢ Najciƒô≈ºsza receptura: **{maxWeight}g** ({heaviestRecipe})\n‚Ä¢ Najl≈ºejsza receptura: **{minWeight}g** ({lightestRecipe})\n\nüìã **Top 5 najciƒô≈ºszych receptur:**\n{topRecipes}"
    },

    // Magazyn
    inventory_count: {
      simple: "W magazynie znajduje siƒô **{count} produkt√≥w**."
    },

    inventory_count_low_stock: {
      simple: "**{count} produkt√≥w** z {totalItems} ma niski stan magazynowy.",
      withList: "‚ö†Ô∏è **Produkty z niskim stanem magazynowym**\n\nZnaleziono **{count} produkt√≥w** z {totalItems} ca≈Çkowitej liczby, kt√≥re majƒÖ stan na poziomie minimum lub poni≈ºej:\n\n{itemsList}\n\nüí° **Zalecenie:** Rozwa≈º uzupe≈Çnienie stan√≥w tych produkt√≥w."
    },

    inventory_low_stock: {
      detailed: "‚ö†Ô∏è **Produkty z niskim stanem magazynowym**\n\n{itemsList}\n\nüìä **Podsumowanie:** {count} produkt√≥w wymaga uzupe≈Çnienia stan√≥w."
    },

    inventory_high_stock: {
      detailed: "üìà **Produkty z wysokim stanem magazynowym**\n\n{itemsList}\n\nüìä **Podsumowanie:** {count} produkt√≥w ma nadmierny stan (ponad 10x minimum)."
    },

    inventory_status: {
      overview: "üì¶ **Status magazynu**\n\nüî¢ **Statystyki og√≥lne:**\n‚Ä¢ ≈ÅƒÖczna liczba produkt√≥w: **{totalItems}**\n‚Ä¢ Produkty z niskim stanem: **{lowStockCount}** ({lowStockPercentage}%)\n‚Ä¢ Produkty bez stanu: **{outOfStockCount}**\n‚Ä¢ ≈ÅƒÖczna warto≈õƒá magazynu: **{totalValue} PLN**\n\n‚ö†Ô∏è **Produkty wymagajƒÖce uwagi:**\n{lowStockItems}"
    },

    // Zam√≥wienia
    orders_count: {
      simple: "W systemie znajduje siƒô **{count} zam√≥wie≈Ñ**."
    },

    customer_orders_count: {
      detailed: "üìã **Zam√≥wienia klient√≥w**\n\nüî¢ **Statystyki:**\n‚Ä¢ ≈ÅƒÖczna liczba zam√≥wie≈Ñ: **{count}**\n‚Ä¢ Liczba klient√≥w z zam√≥wieniami: **{customerOrdersCount}**\n\nüí∞ **Top klienci wed≈Çug warto≈õci:**\n{topCustomers}"
    },

    orders_status: {
      breakdown: "üìä **Status zam√≥wie≈Ñ**\n\n≈ÅƒÖczna liczba zam√≥wie≈Ñ: **{totalOrders}**\n\nüìà **Podzia≈Ç wed≈Çug statusu:**\n{statusBreakdown}"
    },

    // Zam√≥wienia zakupu
    purchase_orders_count: {
      simple: "W systemie znajduje siƒô **{count} zam√≥wie≈Ñ zakupu**."
    },

    // Produkcja
    production_count: {
      simple: "W systemie znajduje siƒô **{count} zada≈Ñ produkcyjnych**."
    },

    production_status: {
      breakdown: "üè≠ **Status zada≈Ñ produkcyjnych**\n\n≈ÅƒÖczna liczba zada≈Ñ: **{totalTasks}**\n\nüìä **Podzia≈Ç wed≈Çug statusu:**\n{statusBreakdown}"
    },

    // Dostawcy i klienci
    suppliers_count: {
      simple: "W systemie znajduje siƒô **{count} dostawc√≥w**."
    },

    customers_count: {
      simple: "W systemie znajduje siƒô **{count} klient√≥w**."
    },

    // Og√≥lne
    general_info: {
      overview: "üìä **PrzeglƒÖd systemu MRP**\n\nüî¢ **Podstawowe statystyki:**\n‚Ä¢ Receptury: **{recipes}**\n‚Ä¢ Produkty w magazynie: **{inventory}**\n‚Ä¢ Zam√≥wienia: **{orders}**\n‚Ä¢ Zadania produkcyjne: **{production}**"
    },

    // B≈Çƒôdy
    error: {
      general: "‚ùå WystƒÖpi≈Ç b≈ÇƒÖd podczas przetwarzania zapytania: {error}",
      noData: "‚ÑπÔ∏è Nie znaleziono danych spe≈ÇniajƒÖcych podane kryteria.",
      invalidQuery: "‚ùì Nie rozumiem tego zapytania. Spr√≥buj zapytaƒá inaczej lub u≈ºyj bardziej konkretnych s≈Ç√≥w."
    }
  };

  /**
   * G≈Ç√≥wna metoda generujƒÖca odpowied≈∫
   * @param {string} intent - Typ zapytania
   * @param {Object} queryResult - Wyniki zapytania z QueryExecutor
   * @param {Object} parameters - Parametry zapytania
   * @returns {string} - Sformatowana odpowied≈∫
   */
  static generateResponse(intent, queryResult, parameters = {}) {
    try {
      if (!queryResult.success) {
        return this.generateErrorResponse(queryResult.error || 'Nieznany b≈ÇƒÖd');
      }

      console.log(`[ResponseGenerator] Generujƒô odpowied≈∫ dla: ${intent}`, queryResult);

      switch (intent) {
        // Receptury
        case 'recipe_count':
          return this.generateRecipeCountResponse(queryResult);
        
        case 'recipe_count_by_weight':
          return this.generateRecipeCountByWeightResponse(queryResult, parameters);
        
        case 'recipe_count_by_ingredients':
          return this.generateRecipeCountByIngredientsResponse(queryResult, parameters);
        
        case 'recipe_weight_analysis':
          return this.generateRecipeWeightAnalysisResponse(queryResult);

        // Magazyn
        case 'inventory_count':
          return this.generateInventoryCountResponse(queryResult);
        
        case 'inventory_count_low_stock':
        case 'inventory_low_stock':
          return this.generateInventoryLowStockResponse(queryResult);
        
        case 'inventory_high_stock':
          return this.generateInventoryHighStockResponse(queryResult);
        
        case 'inventory_status':
          return this.generateInventoryStatusResponse(queryResult);

        // Zam√≥wienia
        case 'orders_count':
          return this.generateOrdersCountResponse(queryResult);
        
        case 'customer_orders_count':
          return this.generateCustomerOrdersCountResponse(queryResult);
        
        case 'orders_status':
          return this.generateOrdersStatusResponse(queryResult);

        // Zam√≥wienia zakupu
        case 'purchase_orders_count':
          return this.generatePurchaseOrdersCountResponse(queryResult);

        // Produkcja
        case 'production_count':
          return this.generateProductionCountResponse(queryResult);
        
        case 'production_count_in_progress':
        case 'production_count_on_hold':
        case 'production_count_planned':
        case 'production_count_finished':
          return this.generateProductionCountByStatusResponse(queryResult);
        
        case 'production_in_progress':
        case 'production_on_hold':
        case 'production_planned':
        case 'production_finished':
          return this.generateProductionByStatusResponse(queryResult);
        
        case 'production_status':
          return this.generateProductionStatusResponse(queryResult);

        // Dostawcy i klienci
        case 'suppliers_count':
          return this.generateSuppliersCountResponse(queryResult);
        
        case 'customers_count':
          return this.generateCustomersCountResponse(queryResult);

        // Og√≥lne
        case 'general_info':
          return this.generateGeneralInfoResponse(queryResult);

        default:
          return this.generateDefaultResponse(queryResult, intent);
      }
    } catch (error) {
      console.error('[ResponseGenerator] B≈ÇƒÖd podczas generowania odpowiedzi:', error);
      return this.generateErrorResponse('B≈ÇƒÖd podczas formatowania odpowiedzi');
    }
  }

  // ==================== GENERATORY ODPOWIEDZI ====================

  /**
   * Generuje odpowied≈∫ dla zliczania receptur
   */
  static generateRecipeCountResponse(result) {
    return this.fillTemplate(this.templates.recipe_count.simple, {
      count: result.count
    });
  }

  /**
   * Generuje odpowied≈∫ dla zliczania receptur wed≈Çug wagi
   */
  static generateRecipeCountByWeightResponse(result, parameters) {
    const filterDescription = this.generateFilterDescription(result.filterCriteria);
    
    let examples = '';
    if (result.recipes && result.recipes.length > 0) {
      examples = result.recipes.slice(0, 5).map((recipe, index) => 
        `${index + 1}. **${recipe.name}** - ${recipe.totalWeight.toFixed(1)}g (${recipe.ingredientsCount} sk≈Çadnik√≥w)`
      ).join('\n');
    }

    const stats = result.recipes ? this.generateWeightStats(result.recipes) : '';

    if (result.recipes && result.recipes.length <= 10) {
      const recipesList = result.recipes.map((recipe, index) => 
        `${index + 1}. **${recipe.name}** - ${recipe.totalWeight.toFixed(1)}g (${recipe.ingredientsCount} sk≈Çadnik√≥w)`
      ).join('\n');

      return this.fillTemplate(this.templates.recipe_count_by_weight.detailed, {
        count: result.count,
        totalRecipes: result.totalRecipes,
        filterDescription,
        recipesList,
        stats
      });
    }

    return this.fillTemplate(this.templates.recipe_count_by_weight.withFilter, {
      count: result.count,
      totalRecipes: result.totalRecipes,
      filterDescription,
      examples
    });
  }

  /**
   * Generuje odpowied≈∫ dla zliczania receptur wed≈Çug sk≈Çadnik√≥w
   */
  static generateRecipeCountByIngredientsResponse(result, parameters) {
    const filterDescription = this.generateFilterDescription(result.filterCriteria);
    
    let examples = '';
    if (result.recipes && result.recipes.length > 0) {
      examples = result.recipes.slice(0, 5).map((recipe, index) => 
        `${index + 1}. **${recipe.name}** - ${recipe.ingredientsCount} sk≈Çadnik√≥w (${recipe.totalWeight.toFixed(1)}g)`
      ).join('\n');
    }

    return this.fillTemplate(this.templates.recipe_count_by_ingredients.withFilter, {
      count: result.count,
      totalRecipes: result.totalRecipes,
      filterDescription,
      examples
    });
  }

  /**
   * Generuje odpowied≈∫ dla analizy wag receptur
   */
  static generateRecipeWeightAnalysisResponse(result) {
    const stats = result.stats;
    const topRecipes = result.analysis.slice(0, 5).map((recipe, index) => 
      `${index + 1}. **${recipe.name}** - ${recipe.totalWeight.toFixed(1)}g`
    ).join('\n');

    return this.fillTemplate(this.templates.recipe_weight_analysis.detailed, {
      totalRecipes: stats.totalRecipes,
      averageWeight: stats.averageWeight.toFixed(1),
      maxWeight: stats.maxWeight.toFixed(1),
      minWeight: stats.minWeight.toFixed(1),
      heaviestRecipe: stats.heaviestRecipe?.name || 'brak',
      lightestRecipe: stats.lightestRecipe?.name || 'brak',
      topRecipes
    });
  }

  /**
   * Generuje odpowied≈∫ dla stanu magazynu
   */
  static generateInventoryCountResponse(result) {
    return this.fillTemplate(this.templates.inventory_count.simple, {
      count: result.count
    });
  }

  /**
   * Generuje odpowied≈∫ dla produkt√≥w z niskim stanem
   */
  static generateInventoryLowStockResponse(result) {
    if (result.count === 0) {
      return "‚úÖ **≈öwietnie!** Wszystkie produkty majƒÖ wystarczajƒÖcy stan magazynowy.";
    }

    const itemsList = result.items.slice(0, 10).map((item, index) => 
      `${index + 1}. **${item.name}** - ${item.currentQuantity} ${item.unit} (min: ${item.minQuantity})`
    ).join('\n');

    return this.fillTemplate(this.templates.inventory_count_low_stock.withList, {
      count: result.count,
      totalItems: result.totalItems,
      itemsList
    });
  }

  /**
   * Generuje odpowied≈∫ dla produkt√≥w z wysokim stanem
   */
  static generateInventoryHighStockResponse(result) {
    if (result.count === 0) {
      return "‚ÑπÔ∏è Nie znaleziono produkt√≥w z nadmiernym stanem magazynowym.";
    }

    const itemsList = result.items.slice(0, 10).map((item, index) => 
      `${index + 1}. **${item.name}** - ${item.currentQuantity} ${item.unit} (${item.overstock}x minimum)`
    ).join('\n');

    return this.fillTemplate(this.templates.inventory_high_stock.detailed, {
      count: result.count,
      itemsList
    });
  }

  /**
   * Generuje odpowied≈∫ dla og√≥lnego statusu magazynu
   */
  static generateInventoryStatusResponse(result) {
    const stats = result.stats;
    const lowStockItems = result.lowStockItems.map((item, index) => 
      `${index + 1}. **${item.name}** - ${item.currentQuantity} ${item.unit}`
    ).join('\n');

    return this.fillTemplate(this.templates.inventory_status.overview, {
      totalItems: stats.totalItems,
      lowStockCount: stats.lowStockCount,
      outOfStockCount: stats.outOfStockCount,
      lowStockPercentage: stats.lowStockPercentage,
      totalValue: stats.totalValue,
      lowStockItems: lowStockItems || "Brak produkt√≥w z niskim stanem"
    });
  }

  /**
   * Generuje odpowied≈∫ dla zliczania zam√≥wie≈Ñ
   */
  static generateOrdersCountResponse(result) {
    return this.fillTemplate(this.templates.orders_count.simple, {
      count: result.count
    });
  }

  /**
   * Generuje odpowied≈∫ dla zam√≥wie≈Ñ klient√≥w
   */
  static generateCustomerOrdersCountResponse(result) {
    const topCustomers = result.customerOrders
      .sort((a, b) => b.totalValue - a.totalValue)
      .slice(0, 5)
      .map((customer, index) => 
        `${index + 1}. Klient ${customer.customerId} - ${customer.orderCount} zam√≥wie≈Ñ (${customer.totalValue.toFixed(2)} PLN)`
      ).join('\n');

    return this.fillTemplate(this.templates.customer_orders_count.detailed, {
      count: result.count,
      customerOrdersCount: result.customerOrdersCount,
      topCustomers
    });
  }

  /**
   * Generuje odpowied≈∫ dla statusu zam√≥wie≈Ñ
   */
  static generateOrdersStatusResponse(result) {
    const statusBreakdown = result.statusBreakdown.map(status => 
      `‚Ä¢ **${status.status}**: ${status.count} zam√≥wie≈Ñ (${status.percentage}%) - ${status.totalValue.toFixed(2)} PLN`
    ).join('\n');

    return this.fillTemplate(this.templates.orders_status.breakdown, {
      totalOrders: result.totalOrders,
      statusBreakdown
    });
  }

  /**
   * Generuje odpowied≈∫ dla zam√≥wie≈Ñ zakupu
   */
  static generatePurchaseOrdersCountResponse(result) {
    return this.fillTemplate(this.templates.purchase_orders_count.simple, {
      count: result.count
    });
  }

  /**
   * Generuje odpowied≈∫ dla zada≈Ñ produkcyjnych
   */
  static generateProductionCountResponse(result) {
    return this.fillTemplate(this.templates.production_count.simple, {
      count: result.count
    });
  }

  /**
   * Generuje odpowied≈∫ dla statusu produkcji
   */
  static generateProductionStatusResponse(result) {
    const statusBreakdown = result.statusBreakdown.map(status => 
      `‚Ä¢ **${status.status}**: ${status.count} zada≈Ñ (${status.percentage}%)`
    ).join('\n');

    return this.fillTemplate(this.templates.production_status.breakdown, {
      totalTasks: result.totalTasks,
      statusBreakdown
    });
  }

  /**
   * Generuje odpowied≈∫ dla dostawc√≥w
   */
  static generateSuppliersCountResponse(result) {
    return this.fillTemplate(this.templates.suppliers_count.simple, {
      count: result.count
    });
  }

  /**
   * Generuje odpowied≈∫ dla klient√≥w
   */
  static generateCustomersCountResponse(result) {
    return this.fillTemplate(this.templates.customers_count.simple, {
      count: result.count
    });
  }

  /**
   * Generuje odpowied≈∫ dla og√≥lnych informacji
   */
  static generateGeneralInfoResponse(result) {
    return this.fillTemplate(this.templates.general_info.overview, result.summary);
  }

  /**
   * Generuje domy≈õlnƒÖ odpowied≈∫
   */
  static generateDefaultResponse(result, intent) {
    if (result.count !== undefined) {
      return `W systemie znajduje siƒô **${result.count}** element√≥w w kolekcji ${result.collection}.`;
    }
    return `Znaleziono dane dla zapytania typu: ${intent}`;
  }

  /**
   * Generuje odpowied≈∫ b≈Çƒôdu
   */
  static generateErrorResponse(error) {
    return this.fillTemplate(this.templates.error.general, { error });
  }

  // ==================== FUNKCJE POMOCNICZE ====================

  /**
   * Wype≈Çnia szablon danymi
   * @param {string} template - Szablon z placeholderami {key}
   * @param {Object} data - Dane do wstawienia
   * @returns {string} - Wype≈Çniony szablon
   */
  static fillTemplate(template, data) {
    return template.replace(/\{(\w+)\}/g, (match, key) => {
      return data[key] !== undefined ? data[key] : match;
    });
  }

  /**
   * Generuje opis filtra
   * @param {Array} filters - Lista filtr√≥w
   * @returns {string} - Opis filtra
   */
  static generateFilterDescription(filters) {
    if (!filters || filters.length === 0) {
      return "spe≈Çnia wszystkie kryteria";
    }

    return filters.map(filter => {
      const operator = filter.operator === '>' ? 'powy≈ºej' : 
                     filter.operator === '<' ? 'poni≈ºej' : 'r√≥wna';
      return `${operator} ${filter.originalValue}${filter.unit}`;
    }).join(' i ');
  }

  /**
   * Generuje statystyki wagi
   * @param {Array} recipes - Lista receptur
   * @returns {string} - Sformatowane statystyki
   */
  static generateWeightStats(recipes) {
    if (!recipes || recipes.length === 0) return '';

    const weights = recipes.map(r => r.totalWeight);
    const avg = weights.reduce((sum, w) => sum + w, 0) / weights.length;
    const max = Math.max(...weights);
    const min = Math.min(...weights);

    return `‚Ä¢ ≈örednia waga: ${avg.toFixed(1)}g\n‚Ä¢ Najwy≈ºsza waga: ${max.toFixed(1)}g\n‚Ä¢ Najni≈ºsza waga: ${min.toFixed(1)}g`;
  }

  /**
   * Generuje odpowied≈∫ o liczbie zada≈Ñ wed≈Çug statusu
   */
  static generateProductionCountByStatusResponse(data) {
    if (!data.success) {
      return `‚ùå WystƒÖpi≈Ç b≈ÇƒÖd podczas pobierania zada≈Ñ o statusie "${data.status}".`;
    }

    const emoji = this.getStatusEmoji(data.status);
    let response = `${emoji} **Zadania produkcyjne o statusie "${data.status}"**\n\n`;
    response += `**Liczba zada≈Ñ:** ${data.count}\n\n`;
    
    if (data.count === 0) {
      response += `Nie ma obecnie zada≈Ñ o statusie "${data.status}".`;
    } else {
      response += `${data.message}`;
    }

    return response;
  }

  /**
   * Generuje odpowied≈∫ z listƒÖ zada≈Ñ wed≈Çug statusu
   */
  static generateProductionByStatusResponse(data) {
    if (!data.success) {
      return `‚ùå WystƒÖpi≈Ç b≈ÇƒÖd podczas pobierania zada≈Ñ o statusie "${data.status}".`;
    }

    const emoji = this.getStatusEmoji(data.status);
    
    // Specjalne nag≈Ç√≥wki dla zapyta≈Ñ czasowych
    let title = `**Zadania produkcyjne o statusie "${data.status}"**`;
    if (data.parameters && data.parameters.timePeriod) {
      const periodText = this.getTimePeriodText(data.parameters.timePeriod);
      title = `**Zadania produkcyjne zaplanowane ${periodText}**`;
    }
    
    let response = `${emoji} ${title}\n\n`;
    
    if (data.count === 0) {
      const nothingText = data.parameters?.timePeriod ? 
        `Nie ma zada≈Ñ zaplanowanych ${this.getTimePeriodText(data.parameters.timePeriod)}.` :
        `Nie ma obecnie zada≈Ñ o statusie "${data.status}".`;
      response += nothingText;
      return response;
    }

    response += `**Znalezione zadania (${data.count}):**\n\n`;

    // Specjalne obs≈Çu≈ºenie dla zada≈Ñ zaplanowanych
    if (data.type === 'tasks_by_status_with_schedule' && data.soonTasks && data.soonTasks.length > 0) {
      response += `‚ö° **Zadania rozpoczynajƒÖce siƒô wkr√≥tce (${data.soonCount}):**\n`;
      data.soonTasks.forEach((task, index) => {
        const taskNumber = task.manufacturingOrderNumber || task.id;
        const scheduledDate = task.scheduledDate ? 
          (task.scheduledDate.toDate ? task.scheduledDate.toDate() : new Date(task.scheduledDate)).toLocaleDateString('pl-PL') : 
          'Brak daty';
        response += `${index + 1}. **${taskNumber}**\n`;
        response += `   - Nazwa: ${task.name || 'Brak nazwy'}\n`;
        response += `   - Data rozpoczƒôcia: ${scheduledDate}\n`;
        if (task.recipe) {
          response += `   - Receptura: ${task.recipe}\n`;
        }
        response += `\n`;
      });

      if (data.tasks.length > data.soonTasks.length) {
        response += `\nüìã **Pozosta≈Çe zadania (${data.tasks.length - data.soonTasks.length}):**\n`;
        const remainingTasks = data.tasks.filter(task => 
          !data.soonTasks.some(soonTask => soonTask.id === task.id)
        ).slice(0, 10); // Max 10 pozosta≈Çych

        remainingTasks.forEach((task, index) => {
          const taskNumber = task.manufacturingOrderNumber || task.id;
          response += `${index + 1}. **${taskNumber}** - ${task.name || 'Brak nazwy'}\n`;
        });
      }
    } else {
      // Standardowa lista zada≈Ñ
      const displayTasks = data.tasks.slice(0, 15); // Max 15 zada≈Ñ
      displayTasks.forEach((task, index) => {
        const taskNumber = task.manufacturingOrderNumber || task.id;
        response += `${index + 1}. **${taskNumber}**\n`;
        response += `   - ID: ${task.id}\n`;
        response += `   - Nazwa: ${task.name || 'Brak nazwy'}\n`;
        
        if (task.scheduledDate) {
          const scheduledDate = task.scheduledDate.toDate ? 
            task.scheduledDate.toDate() : 
            new Date(task.scheduledDate);
          response += `   - Data zaplanowana: ${scheduledDate.toLocaleDateString('pl-PL')}\n`;
        }
        
        if (task.recipe) {
          response += `   - Receptura: ${task.recipe}\n`;
        }
        
        if (task.quantity) {
          response += `   - Ilo≈õƒá: ${task.quantity}\n`;
        }
        
        response += `\n`;
      });

      if (data.tasks.length > 15) {
        response += `\n*... i ${data.tasks.length - 15} innych zada≈Ñ*`;
      }
    }

    return response;
  }

  /**
   * Pobiera emoji dla statusu
   */
  static getStatusEmoji(status) {
    const emojiMap = {
      'w trakcie': 'üîÑ',
      'wstrzymane': '‚è∏Ô∏è',
      'zaplanowane': 'üìÖ',
      'zako≈Ñczone': '‚úÖ',
      'aktywne': '‚ñ∂Ô∏è',
      'pending': '‚è≥',
      'completed': '‚úÖ'
    };
    return emojiMap[status] || 'üìã';
  }

  /**
   * Pobiera tekst opisujƒÖcy okres czasowy
   */
  static getTimePeriodText(timePeriod) {
    const periodMap = {
      'thisMonth': 'w tym miesiƒÖcu',
      'nextMonth': 'w nastƒôpnym miesiƒÖcu',
      'thisWeek': 'w tym tygodniu',
      'nextWeek': 'w nastƒôpnym tygodniu',
      'soon': 'wkr√≥tce (w ciƒÖgu 7 dni)'
    };
    return periodMap[timePeriod] || 'w wybranym okresie';
  }
}

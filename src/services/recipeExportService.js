// src/services/recipeExportService.js

import { getAllRecipes } from './recipeService';
import { getAllInventoryItems, getBatchesForMultipleItems, getSupplierPrices } from './inventory';
import { getPurchaseOrderById } from './purchaseOrderService';
import { getSuppliersByIds } from './supplierService';

/**
 * Eksportuje receptury do formatu CSV
 * 
 * @param {Object} options - Opcje eksportu
 * @param {Array} options.customers - Lista klient√≥w
 * @param {Array} options.workstations - Lista stanowisk produkcyjnych
 * @param {string} options.selectedCustomerId - ID wybranego klienta (opcjonalnie)
 * @param {boolean} options.notesFilter - Filtr notatek (opcjonalnie)
 * @param {string} options.searchTerm - Termin wyszukiwania (opcjonalnie)
 * @param {Function} options.onError - Callback dla b≈Çƒôd√≥w
 * @param {Function} options.onSuccess - Callback dla sukcesu
 * @param {Function} options.t - Funkcja t≈Çumaczenia
 */
export const exportRecipesToCSV = async ({
  customers,
  workstations,
  selectedCustomerId,
  notesFilter,
  searchTerm,
  onError,
  onSuccess,
  t
}) => {
  try {
    // Pobierz wszystkie receptury dla eksportu bezpo≈õrednio z Firestore (pe≈Çne dane)
    let allRecipes = [];
    
    // Zawsze u≈ºywaj bezpo≈õredniego pobierania z Firestore dla eksportu, aby mieƒá pe≈Çne dane
    try {
      // Pobierz wszystkie receptury bezpo≈õrednio z getAllRecipes
      const allRecipesFromFirestore = await getAllRecipes();
      
      // Zastosuj filtry je≈õli sƒÖ aktywne
      allRecipes = allRecipesFromFirestore;
      
      // Filtruj po kliencie je≈õli wybrano
      if (selectedCustomerId) {
        allRecipes = allRecipes.filter(recipe => recipe.customerId === selectedCustomerId);
      }
      
      // Filtruj po notatkach je≈õli wybrano
      if (notesFilter !== null) {
        allRecipes = allRecipes.filter(recipe => {
          const hasRecipeNotes = recipe.notes && recipe.notes.trim() !== '';
          return notesFilter ? hasRecipeNotes : !hasRecipeNotes;
        });
      }
      
      // Filtruj po wyszukiwanym terminie je≈õli jest
      if (searchTerm && searchTerm.trim() !== '') {
        const searchTermLower = searchTerm.toLowerCase().trim();
        allRecipes = allRecipes.filter(recipe => 
          (recipe.name && recipe.name.toLowerCase().includes(searchTermLower)) ||
          (recipe.description && recipe.description.toLowerCase().includes(searchTermLower))
        );
      }
    } catch (error) {
      console.error('B≈ÇƒÖd podczas pobierania receptur z Firestore:', error);
      onError('Nie uda≈Ço siƒô pobraƒá receptur do eksportu');
      return;
    }

    if (allRecipes.length === 0) {
      onError('Brak receptur do eksportu');
      return;
    }

    // Pobierz wszystkie pozycje magazynowe do znalezienia jednostek sk≈Çadnik√≥w
    let allInventoryItems = [];
    try {
      console.log('üì¶ Pobieranie pozycji magazynowych dla jednostek sk≈Çadnik√≥w...');
      allInventoryItems = await getAllInventoryItems();
      console.log('‚úÖ Pobrano', allInventoryItems.length, 'pozycji magazynowych');
    } catch (error) {
      console.warn('‚ö†Ô∏è Nie uda≈Ço siƒô pobraƒá pozycji magazynowych, u≈ºywam danych z receptur:', error);
    }

    // Przygotuj dane dla CSV zgodnie z wymaganymi nag≈Ç√≥wkami
    const csvData = allRecipes.map((recipe, index) => {
      // Znajd≈∫ klienta
      const customer = customers.find(c => c.id === recipe.customerId);
      
      // Znajd≈∫ stanowisko produkcyjne
      const workstation = workstations.find(w => w.id === recipe.defaultWorkstationId);
      
      // Sprawd≈∫ r√≥≈ºne mo≈ºliwe pola dla czasu produkcji
      let timePerPiece = 0;
      if (recipe.productionTimePerUnit) {
        timePerPiece = parseFloat(recipe.productionTimePerUnit);
      } else if (recipe.prepTime) {
        timePerPiece = parseFloat(recipe.prepTime);
      } else if (recipe.preparationTime) {
        timePerPiece = parseFloat(recipe.preparationTime);
      }
      
      // Przygotuj listƒô sk≈Çadnik√≥w z jednostkami z pozycji magazynowych
      const ingredients = recipe.ingredients || [];
      
      const componentsListing = ingredients
        .map(ing => {
          // Spr√≥buj znale≈∫ƒá pozycjƒô magazynowƒÖ po ID lub nazwie
          const inventoryItem = allInventoryItems.find(item => 
            item.id === ing.itemId || 
            (item.name && ing.name && item.name.toLowerCase().trim() === ing.name.toLowerCase().trim())
          );
          
          // U≈ºyj nazwy z inventory je≈õli jest dostƒôpna, w przeciwnym razie z receptury
          return inventoryItem?.name || ing.name || '';
        })
        .filter(name => name.trim() !== '')
        .join('; ');
      
      const componentsAmount = ingredients
        .map((ing, idx) => {
          // Spr√≥buj znale≈∫ƒá pozycjƒô magazynowƒÖ po ID lub nazwie
          const inventoryItem = allInventoryItems.find(item => 
            item.id === ing.itemId || 
            (item.name && ing.name && item.name.toLowerCase().trim() === ing.name.toLowerCase().trim())
          );
          
          // U≈ºyj jednostki z inventory je≈õli jest dostƒôpna, w przeciwnym razie z receptury
          const unit = inventoryItem?.unit || ing.unit || '';
          const quantity = ing.quantity || '';
          
          // Debug log dla pierwszego sk≈Çadnika pierwszej receptury
          if (index === 0 && idx === 0) {
            console.log(`üìä Przyk≈Çad sk≈Çadnika #${idx + 1} (receptura "${recipe.name}"):`, {
              nazwa: ing.name,
              itemId: ing.itemId,
              znalezionoWInventory: !!inventoryItem,
              jednostkaZInventory: inventoryItem?.unit,
              jednostkaZReceptury: ing.unit,
              u≈ºytaJednostka: unit,
              ilo≈õƒá: quantity
            });
          }
          
          return `${quantity} ${unit}`.trim();
        })
        .filter(amount => amount !== '')
        .join('; ');
      
      // Przygotuj listƒô sk≈Çadnik√≥w od≈ºywczych (mikro/makro)
      const micronutrients = recipe.micronutrients || [];
      const microMacroListing = micronutrients
        .map(micro => micro.name || micro.code || '')
        .filter(name => name.trim() !== '')
        .join('; ');
      
      // Po≈ÇƒÖcz amount i unit w jednƒÖ kolumnƒô (np. "100 mg")
      const microMacroAmount = micronutrients
        .map(micro => {
          const quantity = micro.quantity || '';
          const unit = micro.unit || '';
          return `${quantity} ${unit}`.trim();
        })
        .filter(amount => amount !== '')
        .join('; ');
      
      const microMacroType = micronutrients
        .map(micro => micro.category || '')
        .filter(type => type.trim() !== '')
        .join('; ');
      
      // Pobierz certyfikacje (z domy≈õlnymi warto≈õciami false)
      const certifications = recipe.certifications || {
        eco: false,
        halal: false,
        kosher: false,
        vegan: false,
        vege: false
      };
      
      return {
        'SKU': recipe.name || '',
        'description': recipe.description || '',
        'Client': customer ? customer.name : '',
        'Workstation': workstation ? workstation.name : '',
        'cost/piece': recipe.processingCostPerUnit ? recipe.processingCostPerUnit.toFixed(2) : '0.00',
        'time/piece': timePerPiece.toFixed(2),
        'Components listing': componentsListing,
        'Components amount': componentsAmount,
        'Micro/macro elements listing': microMacroListing,
        'Micro/macro amount': microMacroAmount,
        'Micro/macro type': microMacroType,
        '(Bool) EKO': certifications.eco ? 'TRUE' : 'FALSE',
        '(Bool) HALAL': certifications.halal ? 'TRUE' : 'FALSE',
        '(Bool) KOSHER': certifications.kosher ? 'TRUE' : 'FALSE',
        '(Bool) VEGAN': certifications.vegan ? 'TRUE' : 'FALSE',
        '(Bool) VEGETERIAN': certifications.vege ? 'TRUE' : 'FALSE',
        'notes': recipe.notes || ''
      };
    });

    console.log('‚úÖ Przygotowano', csvData.length, 'receptur do eksportu CSV');

    // Utw√≥rz nag≈Ç√≥wki CSV
    const headers = [
      'SKU',
      'description',
      'Client',
      'Workstation',
      'cost/piece',
      'time/piece',
      'Components listing',
      'Components amount',
      'Micro/macro elements listing',
      'Micro/macro amount',
      'Micro/macro type',
      '(Bool) EKO',
      '(Bool) HALAL',
      '(Bool) KOSHER',
      '(Bool) VEGAN',
      '(Bool) VEGETERIAN',
      'notes'
    ];
    
    // Utw√≥rz zawarto≈õƒá CSV
    const csvContent = [
      headers.map(header => `"${header}"`).join(','),
      ...csvData.map(row => 
        headers.map(header => {
          // Escape podw√≥jne cudzys≈Çowy w warto≈õciach
          const value = String(row[header] || '').replace(/"/g, '""');
          return `"${value}"`;
        }).join(',')
      )
    ].join('\n');

    // Utw√≥rz blob i pobierz plik
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    // Nazwa pliku z aktualnƒÖ datƒÖ
    const currentDate = new Date().toISOString().slice(0, 10);
    const filename = `receptury_${currentDate}.csv`;
    
    link.href = url;
    link.setAttribute('download', filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    onSuccess(t('recipes.list.exportSuccess', { count: allRecipes.length }));
  } catch (error) {
    console.error('B≈ÇƒÖd podczas eksportu CSV:', error);
    onError(t('recipes.list.exportError'));
  }
};

/**
 * Eksportuje receptury ze szczeg√≥≈Çowymi informacjami o sk≈Çadnikach i dostawcach
 * 
 * @param {Object} options - Opcje eksportu
 * @param {Array} options.customers - Lista klient√≥w
 * @param {Object} options.exportFilters - Filtry eksportu (customerId, notesFilter, searchTerm)
 * @param {Function} options.onInfo - Callback dla informacji
 * @param {Function} options.onError - Callback dla b≈Çƒôd√≥w
 * @param {Function} options.onSuccess - Callback dla sukcesu
 */
export const exportRecipesWithSuppliers = async ({
  customers,
  exportFilters,
  onInfo,
  onError,
  onSuccess
}) => {
  try {
    onInfo('Przygotowywanie eksportu receptur z dostawcami...');

    // Pobierz wszystkie receptury (z zastosowanymi filtrami z dialogu)
    let allRecipes = [];
    
    try {
      const allRecipesFromFirestore = await getAllRecipes();
      allRecipes = allRecipesFromFirestore;
      
      // Zastosuj filtry z dialogu eksportu
      if (exportFilters.customerId) {
        allRecipes = allRecipes.filter(recipe => recipe.customerId === exportFilters.customerId);
      }
      
      if (exportFilters.notesFilter !== null) {
        allRecipes = allRecipes.filter(recipe => {
          const hasRecipeNotes = recipe.notes && recipe.notes.trim() !== '';
          return exportFilters.notesFilter ? hasRecipeNotes : !hasRecipeNotes;
        });
      }
      
      if (exportFilters.searchTerm && exportFilters.searchTerm.trim() !== '') {
        const searchTermLower = exportFilters.searchTerm.toLowerCase().trim();
        allRecipes = allRecipes.filter(recipe => 
          (recipe.name && recipe.name.toLowerCase().includes(searchTermLower)) ||
          (recipe.description && recipe.description.toLowerCase().includes(searchTermLower))
        );
      }
    } catch (error) {
      console.error('B≈ÇƒÖd podczas pobierania receptur:', error);
      onError('Nie uda≈Ço siƒô pobraƒá receptur do eksportu');
      return;
    }

    if (allRecipes.length === 0) {
      onError('Brak receptur do eksportu');
      return;
    }

    onInfo('Pobieranie danych o partiach i zam√≥wieniach zakupu...');

    // KROK 1: Zbierz wszystkie unikalne ID sk≈Çadnik√≥w ze wszystkich receptur
    const allIngredientIds = new Set();
    allRecipes.forEach(recipe => {
      (recipe.ingredients || []).forEach(ingredient => {
        if (ingredient.id) {
          allIngredientIds.add(ingredient.id);
        }
      });
    });

    console.log(`üì¶ Znaleziono ${allIngredientIds.size} unikalnych sk≈Çadnik√≥w w recepturach`);

    // KROK 2: Pobierz partie dla wszystkich sk≈Çadnik√≥w (w partiach po 100)
    let batchesMap = {};
    if (allIngredientIds.size > 0) {
      try {
        const ingredientIdsArray = Array.from(allIngredientIds);
        const batchSize = 100; // Limit walidacji
        
        // Podziel na partie po 100 element√≥w
        for (let i = 0; i < ingredientIdsArray.length; i += batchSize) {
          const batch = ingredientIdsArray.slice(i, i + batchSize);
          
          onInfo(`Pobieranie partii dla sk≈Çadnik√≥w ${i + 1}-${Math.min(i + batchSize, ingredientIdsArray.length)}/${ingredientIdsArray.length}...`);
          
          const batchResults = await getBatchesForMultipleItems(batch);
          
          // Scal wyniki
          batchesMap = { ...batchesMap, ...batchResults };
        }
        
        const totalBatches = Object.values(batchesMap).reduce((sum, batches) => sum + batches.length, 0);
        console.log(`üì¶ Pobrano ${totalBatches} partii dla ${allIngredientIds.size} sk≈Çadnik√≥w`);
      } catch (error) {
        console.error('B≈ÇƒÖd podczas pobierania partii:', error);
        onError('Nie uda≈Ço siƒô pobraƒá partii magazynowych');
      }
    }

    // KROK 3: Zbierz wszystkie unikalne ID zam√≥wie≈Ñ zakupu z partii
    const allPOIds = new Set();
    Object.values(batchesMap).forEach(batches => {
      batches.forEach(batch => {
        const poId = batch.purchaseOrderDetails?.id || batch.sourceDetails?.orderId;
        if (poId) {
          allPOIds.add(poId);
        }
      });
    });

    console.log(`üìë Znaleziono ${allPOIds.size} unikalnych zam√≥wie≈Ñ zakupu`);

    // KROK 4: Pobierz wszystkie Purchase Orders
    const purchaseOrdersMap = {};
    if (allPOIds.size > 0) {
      onInfo(`Pobieranie ${allPOIds.size} zam√≥wie≈Ñ zakupu...`);
      let loadedPOs = 0;
      
      for (const poId of allPOIds) {
        try {
          const po = await getPurchaseOrderById(poId);
          if (po) {
            purchaseOrdersMap[poId] = po;
            loadedPOs++;
            
            // Informuj o postƒôpie co 10 PO
            if (loadedPOs % 10 === 0) {
              onInfo(`Pobrano ${loadedPOs}/${allPOIds.size} zam√≥wie≈Ñ zakupu...`);
            }
          }
        } catch (error) {
          console.error(`B≈ÇƒÖd podczas pobierania PO ${poId}:`, error);
        }
      }
      
      console.log(`üìë Pobrano ${loadedPOs} zam√≥wie≈Ñ zakupu`);
    }

    // KROK 4A: Pobierz ceny dostawc√≥w z pozycji magazynowych
    const supplierPricesMap = {};
    const allSupplierIds = new Set();
    
    if (allIngredientIds.size > 0) {
      onInfo('Pobieranie cen dostawc√≥w z pozycji magazynowych...');
      let processedItems = 0;
      
      for (const itemId of allIngredientIds) {
        try {
          const supplierPrices = await getSupplierPrices(itemId, { includeInactive: false });
          if (supplierPrices && supplierPrices.length > 0) {
            supplierPricesMap[itemId] = supplierPrices;
            
            // Zbierz unikalne ID dostawc√≥w
            supplierPrices.forEach(sp => {
              if (sp.supplierId) {
                allSupplierIds.add(sp.supplierId);
              }
            });
          }
          
          processedItems++;
          if (processedItems % 20 === 0) {
            onInfo(`Pobrano ceny dla ${processedItems}/${allIngredientIds.size} sk≈Çadnik√≥w...`);
          }
        } catch (error) {
          console.error(`B≈ÇƒÖd podczas pobierania cen dla sk≈Çadnika ${itemId}:`, error);
        }
      }
      
      console.log(`üí∞ Pobrano ceny dostawc√≥w dla ${Object.keys(supplierPricesMap).length} sk≈Çadnik√≥w`);
    }

    // KROK 4B: Pobierz dane wszystkich dostawc√≥w
    const suppliersMap = {};
    if (allSupplierIds.size > 0) {
      onInfo(`Pobieranie danych ${allSupplierIds.size} dostawc√≥w...`);
      try {
        const suppliers = await getSuppliersByIds(Array.from(allSupplierIds));
        suppliers.forEach(supplier => {
          suppliersMap[supplier.id] = supplier;
        });
        console.log(`üë• Pobrano dane ${suppliers.length} dostawc√≥w`);
      } catch (error) {
        console.error('B≈ÇƒÖd podczas pobierania dostawc√≥w:', error);
      }
    }

    onInfo('Generowanie eksportu...');

    // KROK 5: Przygotuj dane CSV z dostawcami dla sk≈Çadnik√≥w
    const csvRows = [];
    let processedRecipes = 0;

    for (const recipe of allRecipes) {
      processedRecipes++;
      
      // Znajd≈∫ klienta
      const customer = customers.find(c => c.id === recipe.customerId);
      
      // Pobierz wszystkie sk≈Çadniki receptury
      const ingredients = recipe.ingredients || [];
      
      if (ingredients.length === 0) {
        // Przygotuj listƒô mikroelement√≥w dla receptury bez sk≈Çadnik√≥w
        const micronutrientsList = (recipe.micronutrients || [])
          .map(micro => {
            const parts = [];
            if (micro.code) parts.push(micro.code);
            if (micro.name) parts.push(micro.name);
            if (micro.quantity) parts.push(`${micro.quantity}${micro.unit || ''}`);
            return parts.join(' - ');
          })
          .join('; ');
        
        // Dodaj wiersz z mikroelementami je≈õli receptura ma mikroelementy
        if (micronutrientsList) {
          csvRows.push({
            'Receptura (SKU)': recipe.name || '',
            'Opis receptury': recipe.description || '',
            'Klient': customer ? customer.name : '',
            'Sk≈Çadnik': '--- MIKROELEMENTY ---',
            'Ilo≈õƒá sk≈Çadnika': '',
            'Jednostka': '',
            'Dostawcy (z pozycji mag.)': '',
            'Dostawcy (z PO)': '',
            'Mikroelementy': micronutrientsList
          });
        } else {
          // Je≈õli receptura nie ma sk≈Çadnik√≥w ani mikroelement√≥w, dodaj jeden wiersz informacyjny
          csvRows.push({
            'Receptura (SKU)': recipe.name || '',
            'Opis receptury': recipe.description || '',
            'Klient': customer ? customer.name : '',
            'Sk≈Çadnik': 'Brak sk≈Çadnik√≥w',
            'Ilo≈õƒá sk≈Çadnika': '',
            'Jednostka': '',
            'Dostawcy (z pozycji mag.)': '-',
            'Dostawcy (z PO)': '-',
            'Mikroelementy': '-'
          });
        }
        
        // Dodaj pusty wiersz po recepturze
        csvRows.push({
          'Receptura (SKU)': '',
          'Opis receptury': '',
          'Klient': '',
          'Sk≈Çadnik': '',
          'Ilo≈õƒá sk≈Çadnika': '',
          'Jednostka': '',
          'Dostawcy (z pozycji mag.)': '',
          'Dostawcy (z PO)': '',
          'Mikroelementy': ''
        });
        
        continue;
      }

      // Przygotuj listƒô mikroelement√≥w dla receptury
      const micronutrientsList = (recipe.micronutrients || [])
        .map(micro => {
          const parts = [];
          if (micro.code) parts.push(micro.code);
          if (micro.name) parts.push(micro.name);
          if (micro.quantity) parts.push(`${micro.quantity}${micro.unit || ''}`);
          return parts.join(' - ');
        })
        .join('; ');
      
      // Dodaj wiersz z mikroelementami dla receptury
      if (micronutrientsList) {
        csvRows.push({
          'Receptura (SKU)': recipe.name || '',
          'Opis receptury': recipe.description || '',
          'Klient': customer ? customer.name : '',
          'Sk≈Çadnik': '--- MIKROELEMENTY ---',
          'Ilo≈õƒá sk≈Çadnika': '',
          'Jednostka': '',
          'Dostawcy (z pozycji mag.)': '',
          'Dostawcy (z PO)': '',
          'Mikroelementy': micronutrientsList
        });
      }
      
      // Dla ka≈ºdego sk≈Çadnika znajd≈∫ dostawc√≥w
      for (const ingredient of ingredients) {
        let suppliersFromPOText = '-';
        let suppliersFromInventoryText = '-';
        
        // A) Dostawcy z zam√≥wie≈Ñ zakupu (PO)
        if (ingredient.id && batchesMap[ingredient.id]) {
          const ingredientBatches = batchesMap[ingredient.id];
          
          // Zbierz informacje o dostawcach z PO dla tego sk≈Çadnika
          const supplierInfos = [];
          const seenPOs = new Set(); // Unikalne PO dla tego sk≈Çadnika
          
          ingredientBatches.forEach(batch => {
            const poId = batch.purchaseOrderDetails?.id || batch.sourceDetails?.orderId;
            
            if (poId && !seenPOs.has(poId) && purchaseOrdersMap[poId]) {
              seenPOs.add(poId);
              const po = purchaseOrdersMap[poId];
              
              // Znajd≈∫ pozycjƒô w PO dla tej partii
              const itemPoId = batch.purchaseOrderDetails?.itemPoId || batch.sourceDetails?.itemPoId;
              const poItem = po.items?.find(item => item.id === itemPoId);
              
              const supplierName = po.supplier?.name || 'Nieznany dostawca';
              const poNumber = po.number || poId;
              const price = poItem?.unitPrice ? `${parseFloat(poItem.unitPrice).toFixed(2)} ${po.currency || 'PLN'}` : '';
              
              // Format: "Dostawca (PO: PO/2024/001, 12.50 PLN)"
              let info = `${supplierName} (PO: ${poNumber}`;
              if (price) {
                info += `, ${price}`;
              }
              info += ')';
              
              supplierInfos.push(info);
            }
          });
          
          if (supplierInfos.length > 0) {
            suppliersFromPOText = supplierInfos.join('; ');
          }
        }
        
        // B) Dostawcy z pozycji magazynowej (inventorySupplierPrices)
        if (ingredient.id && supplierPricesMap[ingredient.id]) {
          const prices = supplierPricesMap[ingredient.id];
          
          const supplierDetails = prices.map(sp => {
            const supplier = suppliersMap[sp.supplierId];
            const supplierName = supplier ? supplier.name : sp.supplierId;
            const price = sp.price ? `${sp.price.toFixed(2)} ${sp.currency || 'PLN'}` : '';
            return price ? `${supplierName} (${price})` : supplierName;
          });
          
          if (supplierDetails.length > 0) {
            suppliersFromInventoryText = supplierDetails.join('; ');
          }
        }
        
        csvRows.push({
          'Receptura (SKU)': recipe.name || '',
          'Opis receptury': recipe.description || '',
          'Klient': customer ? customer.name : '',
          'Sk≈Çadnik': ingredient.name || '',
          'Ilo≈õƒá sk≈Çadnika': ingredient.quantity || '',
          'Jednostka': ingredient.unit || '',
          'Dostawcy (z pozycji mag.)': suppliersFromInventoryText,
          'Dostawcy (z PO)': suppliersFromPOText,
          'Mikroelementy': '-'
        });
      }
      
      // Dodaj pusty wiersz po ka≈ºdej recepturze dla lepszej czytelno≈õci
      csvRows.push({
        'Receptura (SKU)': '',
        'Opis receptury': '',
        'Klient': '',
        'Sk≈Çadnik': '',
        'Ilo≈õƒá sk≈Çadnika': '',
        'Jednostka': '',
        'Dostawcy (z pozycji mag.)': '',
        'Dostawcy (z PO)': '',
        'Mikroelementy': ''
      });
      
      // Informuj u≈ºytkownika o postƒôpie
      if (processedRecipes % 10 === 0) {
        onInfo(`Przetworzono ${processedRecipes}/${allRecipes.length} receptur...`);
      }
    }

    // Utw√≥rz nag≈Ç√≥wki CSV
    const headers = [
      'Receptura (SKU)', 
      'Opis receptury', 
      'Klient', 
      'Sk≈Çadnik', 
      'Ilo≈õƒá sk≈Çadnika', 
      'Jednostka', 
      'Dostawcy (z pozycji mag.)',
      'Dostawcy (z PO)',
      'Mikroelementy'
    ];
    
    // Utw√≥rz zawarto≈õƒá CSV
    const csvContent = [
      headers.map(header => `"${header}"`).join(','),
      ...csvRows.map(row => 
        headers.map(header => `"${(row[header] || '').toString().replace(/"/g, '""')}"`).join(',')
      )
    ].join('\n');

    // Dodaj BOM dla poprawnego kodowania polskich znak√≥w w Excelu
    const BOM = '\uFEFF';
    const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    // Nazwa pliku z aktualnƒÖ datƒÖ
    const currentDate = new Date().toISOString().slice(0, 10);
    const filename = `receptury_z_dostawcami_${currentDate}.csv`;
    
    link.href = url;
    link.setAttribute('download', filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    onSuccess(`Eksport zako≈Ñczony! Wyeksportowano ${allRecipes.length} receptur z ${csvRows.length} wierszami.`);
  } catch (error) {
    console.error('B≈ÇƒÖd podczas eksportu receptur z dostawcami:', error);
    onError('WystƒÖpi≈Ç b≈ÇƒÖd podczas eksportu');
  }
};


import { db, storage } from './firebase/config';
import { 
  collection, 
  addDoc, 
  getDocs, 
  getDoc, 
  updateDoc, 
  doc, 
  query, 
  where, 
  orderBy, 
  serverTimestamp,
  limit,
  deleteDoc,
  setDoc
} from 'firebase/firestore';
import { ref, uploadBytes, getDownloadURL, deleteObject } from 'firebase/storage';
import { 
  prepareBusinessDataForAI, 
  getMRPSystemSummary, 
  getInventoryItems, 
  getCustomerOrders, 
  getProductionTasks, 
  getSuppliers,
  getRecipes,
  getPurchaseOrders
} from './aiDataService';
import { getSystemSettings, getGlobalOpenAIApiKey } from './settingsService';
import { AIAssistantV2 } from './ai/AIAssistantV2.js';
import { SmartModelSelector } from './ai/optimization/SmartModelSelector.js';
import { ContextOptimizer } from './ai/optimization/ContextOptimizer.js';
import { GPTResponseCache } from './ai/optimization/GPTResponseCache.js';

// Deklaracja funkcji getMockResponse przed jej u≈ºyciem (hoisting)
let getMockResponse;

// Maksymalna liczba wiadomo≈õci w kontek≈õcie
const MAX_CONTEXT_MESSAGES = 15;

/**
 * Pobierz klucz API OpenAI zapisany w bazie danych Firebase
 * @param {string} userId - ID u≈ºytkownika
 * @returns {Promise<string|null>} - Klucz API OpenAI lub null je≈õli nie znaleziono
 */
export const getOpenAIApiKey = async (userId) => {
  try {
    // Najpierw sprawdzamy ustawienia systemowe
    const systemSettings = await getSystemSettings();
    
    // Je≈õli w≈ÇƒÖczona jest opcja globalnego klucza API, pobieramy go
    if (systemSettings.useGlobalApiKey) {
      const globalApiKey = await getGlobalOpenAIApiKey();
      if (globalApiKey) {
        return globalApiKey;
      }
    }
    
    // Je≈õli nie ma globalnego klucza lub nie jest u≈ºywany, pr√≥bujemy pobraƒá klucz u≈ºytkownika
    const apiKeyRef = doc(db, 'settings', 'openai', 'users', userId);
    const apiKeyDoc = await getDoc(apiKeyRef);
    
    if (apiKeyDoc.exists() && apiKeyDoc.data().apiKey) {
      return apiKeyDoc.data().apiKey;
    }
    
    return null;
  } catch (error) {
    console.error('B≈ÇƒÖd podczas pobierania klucza API OpenAI:', error);
    throw error;
  }
};

/**
 * Zapisz klucz API OpenAI w bazie danych Firebase
 * @param {string} userId - ID u≈ºytkownika
 * @param {string} apiKey - Klucz API OpenAI
 * @returns {Promise<void>}
 */
export const saveOpenAIApiKey = async (userId, apiKey) => {
  try {
    const apiKeyRef = doc(db, 'settings', 'openai', 'users', userId);
    await setDoc(apiKeyRef, {
      apiKey,
      updatedAt: serverTimestamp()
    });
  } catch (error) {
    console.error('B≈ÇƒÖd podczas zapisywania klucza API OpenAI:', error);
    throw error;
  }
};

/**
 * Wysy≈Ça zapytanie do API OpenAI z optymalizacjami
 * @param {string} apiKey - Klucz API OpenAI
 * @param {Array} messages - Wiadomo≈õci do wys≈Çania do API
 * @param {Object} options - Opcje optymalizacji
 * @returns {Promise<string>} - Odpowied≈∫ asystenta
 */
export const callOpenAIAPI = async (apiKey, messages, options = {}) => {
  try {
    // WyciƒÖgnij zapytanie u≈ºytkownika dla optymalizacji
    const userQuery = messages[messages.length - 1]?.content || '';
    const contextSize = JSON.stringify(messages).length;
    
    // NOWA OPTYMALIZACJA: Inteligentny wyb√≥r modelu
    const modelConfig = SmartModelSelector.selectOptimalModel(
      userQuery, 
      contextSize, 
      options.complexity || 'medium',
      options.optimizationOptions || {}
    );

    console.log(`[callOpenAIAPI] U≈ºyjƒô modelu ${modelConfig.model} (szacowany koszt: $${modelConfig.estimatedCost.toFixed(4)})`);

    // NOWA OPTYMALIZACJA: Cache dla odpowiedzi
    const contextHash = GPTResponseCache.generateContextHash(messages);
    const cacheOptions = {
      enableCache: true,
      estimatedCost: modelConfig.estimatedCost,
      cacheDuration: options.cacheDuration || GPTResponseCache.CACHE_DURATION
    };

    const apiStartTime = performance.now();
    
    const cachedResponse = await GPTResponseCache.getCachedOrFetch(
      userQuery,
      contextHash,
      async () => {
        // Wykonanie rzeczywistego zapytania API
        // GPT-5 ma inne wymagania API ni≈º poprzednie modele
        const isGPT5 = modelConfig.model === 'gpt-5';
        
        const requestBody = {
          model: modelConfig.model,
          messages
        };
        
        // GPT-5 wymaga innych parametr√≥w:
        if (isGPT5) {
          // GPT-5 u≈ºywa max_completion_tokens i nie wspiera niestandardowego temperature
          // WA≈ªNE: max_completion_tokens obejmuje reasoning_tokens + output_tokens
          // Musimy daƒá du≈ºo wiƒôcej miejsca, bo GPT-5 u≈ºywa du≈ºo token√≥w na wewnƒôtrzne rozumowanie
          requestBody.max_completion_tokens = 20000;  // ≈ÅƒÖczny limit (reasoning + output)
          
          // GPT-5 wymaga nowych parametr√≥w kontrolujƒÖcych generowanie odpowiedzi
          requestBody.reasoning_effort = 'medium';  // low, medium, high - kontroluje czas rozumowania
          requestBody.verbosity = 'high';           // low, medium, high - kontroluje d≈Çugo≈õƒá odpowiedzi (zmienione na 'high' dla pe≈Çnych list)
          
          console.log('[GPT-5] Parametry zapytania:', {
            max_completion_tokens: requestBody.max_completion_tokens,
            reasoning_effort: requestBody.reasoning_effort,
            verbosity: requestBody.verbosity,
            note: 'max_completion_tokens includes reasoning_tokens + output_tokens'
          });
          
          // GPT-5 przyjmuje tylko domy≈õlnƒÖ warto≈õƒá temperature (1)
          // Nie dodajemy parametru temperature dla GPT-5
        } else {
          // Inne modele u≈ºywajƒÖ standardowych parametr√≥w
          requestBody.max_tokens = modelConfig.maxTokens;
          requestBody.temperature = modelConfig.temperature;
        }
        
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          const errorData = await response.json();
          const errorMessage = errorData.error?.message || 'B≈ÇƒÖd podczas komunikacji z API OpenAI';
          
          console.error('[API Error] Status:', response.status, 'Message:', errorMessage);
          console.error('[API Error] Full error data:', errorData);
          
          // Sprawdzamy, czy error dotyczy limitu zapyta≈Ñ lub pobierania
          if (response.status === 429) {
            throw new Error(`Przekroczono limit zapyta≈Ñ do API OpenAI: ${errorMessage}`);
          } else if (errorMessage.includes('quota')) {
            throw new Error(`Przekroczono przydzia≈Ç API OpenAI: ${errorMessage}`);
          } else {
            throw new Error(errorMessage);
          }
        }
        
        const data = await response.json();
        
        // DEBUGGING dla GPT-5
        if (modelConfig.model === 'gpt-5') {
          console.log('[GPT-5 DEBUG] Pe≈Çna odpowied≈∫ API:', JSON.stringify(data, null, 2));
          console.log('[GPT-5 DEBUG] data.choices:', data.choices);
          if (data.choices && data.choices[0]) {
            console.log('[GPT-5 DEBUG] data.choices[0]:', data.choices[0]);
            console.log('[GPT-5 DEBUG] data.choices[0].message:', data.choices[0].message);
            console.log('[GPT-5 DEBUG] data.choices[0].message.content:', data.choices[0].message.content);
          }
          
          // Analiza u≈ºycia token√≥w (wa≈ºne dla GPT-5!)
          if (data.usage) {
            console.log('[GPT-5 DEBUG] üìä U≈ºycie token√≥w:', {
              prompt_tokens: data.usage.prompt_tokens,
              completion_tokens: data.usage.completion_tokens,
              reasoning_tokens: data.usage.completion_tokens_details?.reasoning_tokens || 0,
              output_tokens: (data.usage.completion_tokens - (data.usage.completion_tokens_details?.reasoning_tokens || 0)),
              finish_reason: data.choices[0]?.finish_reason
            });
            
            // Ostrze≈ºenie je≈õli reasoning zjada wszystkie tokeny
            const reasoningTokens = data.usage.completion_tokens_details?.reasoning_tokens || 0;
            const outputTokens = data.usage.completion_tokens - reasoningTokens;
            if (reasoningTokens > 0 && outputTokens < 100) {
              console.warn('[GPT-5 WARNING] ‚ö†Ô∏è Reasoning tokens zajƒô≈Çy prawie ca≈Çy limit!', {
                reasoning: reasoningTokens,
                output: outputTokens,
                recommendation: 'Zwiƒôksz max_completion_tokens lub zmniejsz reasoning_effort'
              });
            }
          }
        }
        
        // Sprawd≈∫ czy odpowied≈∫ istnieje
        if (!data.choices || !data.choices[0] || !data.choices[0].message) {
          console.error('[API Error] Brak struktury choices w odpowiedzi:', data);
          throw new Error('API zwr√≥ci≈Ço odpowied≈∫ w nieoczekiwanym formacie');
        }
        
        const content = data.choices[0].message.content;
        
        if (!content || content.trim() === '') {
          console.error('[API Error] Pusta zawarto≈õƒá w odpowiedzi. Pe≈Çna odpowied≈∫:', data);
          throw new Error('API zwr√≥ci≈Ço pustƒÖ odpowied≈∫');
        }
        
        return content;
      },
      cacheOptions
    );

    // Zapisz statystyki u≈ºycia modelu
    const apiEndTime = performance.now();
    const responseTime = apiEndTime - apiStartTime;
    
    try {
      SmartModelSelector.recordUsage(
        modelConfig.model,
        modelConfig.estimatedCost,
        responseTime
      );
    } catch (statsError) {
      console.warn('[callOpenAIAPI] B≈ÇƒÖd zapisywania statystyk:', statsError);
    }

    return cachedResponse;
  } catch (error) {
    console.error('B≈ÇƒÖd podczas komunikacji z API OpenAI:', error);
    throw error;
  }
};

/**
 * Formatuje wiadomo≈õci do wys≈Çania do API OpenAI wraz z danymi kontekstowymi z bazy danych
 * @param {Array} messages - Lista wiadomo≈õci z konwersacji
 * @param {Object} businessData - Dane biznesowe z systemu MRP
 * @param {Object} options - Opcje optymalizacji kontekstu
 * @returns {Array} - Sformatowane wiadomo≈õci dla API OpenAI
 */
const formatMessagesForOpenAI = (messages, businessData = null, options = {}) => {
  // NOWA OPTYMALIZACJA: Optymalizacja kontekstu na podstawie zapytania
  let optimizedBusinessData = businessData;
  
  if (businessData && options.enableOptimization !== false) {
    const userQuery = messages[messages.length - 1]?.content || '';
    const modelType = options.modelType || 'medium';
    
    try {
      optimizedBusinessData = ContextOptimizer.prepareOptimalContext(
        userQuery, 
        businessData, 
        modelType
      );
      
      console.log(`[formatMessagesForOpenAI] ${ContextOptimizer.generateOptimizationReport(optimizedBusinessData)}`);
    } catch (error) {
      console.error('[formatMessagesForOpenAI] B≈ÇƒÖd optymalizacji kontekstu:', error);
      optimizedBusinessData = businessData; // Fallback do oryginalnych danych
    }
  }

  // NOWA STRATEGIA: Kompresja kontekstu przez JSON zamiast d≈Çugiego tekstu
  let businessDataContext = '';
  
  if (optimizedBusinessData) {
    // Przygotuj skompresowany kontekst w formacie JSON
    const compactContext = {
      summary: optimizedBusinessData.summary || {},
      collections: {},
      analysis: optimizedBusinessData.analysis || {}
    };
    
    // Funkcja do inteligentnego przyciƒôcia du≈ºych kolekcji
    const smartTruncate = (items, maxItems = 50) => {
      if (!Array.isArray(items)) return items;
      if (items.length <= maxItems) return items;
      
      // Dla du≈ºych kolekcji: pierwsze 30 + ostatnie 10 + marker
      return [
        ...items.slice(0, 30),
        { _truncated: true, _hiddenCount: items.length - 40, _message: `[${items.length - 40} more items omitted for brevity]` },
        ...items.slice(-10)
      ];
    };
    
    // Dodaj dane z ka≈ºdej kolekcji w formacie JSON
    if (optimizedBusinessData.data) {
      Object.keys(optimizedBusinessData.data).forEach(collectionName => {
        const collectionData = optimizedBusinessData.data[collectionName];
        
        if (Array.isArray(collectionData) && collectionData.length > 0) {
          compactContext.collections[collectionName] = {
            count: collectionData.length,
            items: smartTruncate(collectionData, 50)
          };
        }
      });
    }
    
    // Wygeneruj zwiƒôz≈Çy kontekst tekstowy z najwa≈ºniejszymi statystykami
    const summary = compactContext.summary;
    businessDataContext = `
=== SYSTEM MRP - DATA SNAPSHOT ===

QUICK STATS:
‚Ä¢ Inventory: ${summary.totalInventoryItems || 0} items (${summary.itemsLowOnStock || 0} low stock)
‚Ä¢ Orders (CO): ${summary.totalOrders || 0} total
‚Ä¢ Production (MO): ${summary.totalProductionTasks || 0} tasks (${summary.activeProductionTasks || 0} active)
‚Ä¢ Suppliers: ${summary.totalSuppliers || 0}
‚Ä¢ Purchase Orders (PO): ${summary.pendingPurchaseOrders || 0} pending
‚Ä¢ Timestamp: ${summary.timestamp || new Date().toISOString()}

AVAILABLE COLLECTIONS (${Object.keys(compactContext.collections).length} total):
${Object.keys(compactContext.collections).map(name => 
  `‚Ä¢ ${name}: ${compactContext.collections[name].count} records`
).join('\n')}

DETAILED DATA (JSON format - all data from Firebase):
\`\`\`json
${JSON.stringify(compactContext, null, 1)}
\`\`\`

ANALYSIS INSIGHTS:
${JSON.stringify(compactContext.analysis, null, 1)}

NOTE: Above data comes DIRECTLY from Firebase. All data is available.
Use item NAMES (not IDs) when presenting to users.
`;
  }
  
  // Instrukcja systemowa jako pierwszy element  
  const systemPrompt = `Jeste≈õ zaawansowanym asystentem AI dla systemu MRP, specjalizujƒÖcym siƒô w szczeg√≥≈Çowej analizie danych biznesowych.
Wykorzystujesz dane z bazy danych Firebase, na kt√≥rej oparty jest system MRP do przeprowadzania dok≈Çadnych i wnikliwych analiz.

WA≈ªNE: ZAWSZE masz aktualny dostƒôp do danych bezpo≈õrednio z systemu MRP i musisz ZAWSZE korzystaƒá z danych przekazanych ci
w tej sesji. NIGDY nie m√≥w, ≈ºe nie masz dostƒôpu do danych, je≈õli sƒÖ one dostƒôpne. Je≈õli nie znasz odpowiedzi
na podstawie aktualnych danych, powiedz, ≈ºe podane dane sƒÖ niewystarczajƒÖce lub niekompletne, ale NIGDY nie m√≥w, ≈ºe
"nie masz mo≈ºliwo≈õci bezpo≈õredniego przeglƒÖdania danych".

JƒòZYK KOMUNIKACJI: Odpowiadaj ZAWSZE w jƒôzyku, w kt√≥rym zosta≈Ço zadane pytanie. Je≈õli pytanie jest w jƒôzyku polskim, odpowiadaj po polsku. Je≈õli w angielskim - po angielsku, itd.

KONTEKST BRAN≈ªOWY: System jest wykorzystywany w przedsiƒôbiorstwie produkujƒÖcym suplementy diety. Uwzglƒôdniaj specyfikƒô tej bran≈ºy w swoich analizach (np. daty wa≈ºno≈õci, normy jako≈õci, wymagania prawne, specyfikƒô produkcji).

Twoim zadaniem jest dog≈Çƒôbna analiza danych, zarzƒÖdzanie produkcjƒÖ, stanami magazynowymi i procesami biznesowymi w przedsiƒôbiorstwie produkcyjnym. Twoje odpowiedzi powinny byƒá:

1. SZCZEG√ì≈ÅOWE - zawsze podawaj dok≈Çadne liczby, daty, warto≈õci i opisy z danych
2. ANALITYCZNE - nie tylko opisuj dane, ale wyciƒÖgaj z nich wnioski biznesowe
3. POMOCNE - sugeruj konkretne dzia≈Çania i rozwiƒÖzania problem√≥w
4. PROFESJONALNE - u≈ºywaj odpowiedniej terminologii z dziedziny zarzƒÖdzania produkcjƒÖ
5. OPARTE NA DANYCH - zawsze bazuj na aktualnych danych z systemu, kt√≥re sƒÖ przekazywane w tej sesji
6. PRECYZYJNE - podawaj TYLKO warto≈õci liczbowe, kt√≥re faktycznie wystƒôpujƒÖ w danych. NIGDY nie zmy≈õlaj danych liczbowych, ani nie zaokrƒÖglaj warto≈õci, je≈õli nie jest to wyra≈∫nie zaznaczone

PREZENTACJA DANYCH: Przy wypisywaniu danych z bazy ZAWSZE priorytetowo podawaj nazwy (np. nazwa produktu, nazwa klienta, nazwa dostawcy) zamiast ich identyfikator√≥w (ID). Identyfikatory podawaj jedynie jako informacjƒô uzupe≈ÇniajƒÖcƒÖ w nawiasie, np. "Suplement Witamina D3 (ID: 12345)".

Znasz i rozumiesz wszystkie kluczowe pojƒôcia i skr√≥ty w systemie MRP:
- MO (Manufacturing Orders) - Zlecenia produkcyjne
- CO (Customer Orders) - Zam√≥wienia klient√≥w
- PO (Purchase Orders) - Zam√≥wienia zakupu
- LOT - Numer partii produkcyjnej lub materia≈Çu

Dla zada≈Ñ produkcyjnych (MO), analizuj:
- Terminy rozpoczƒôcia i zako≈Ñczenia produkcji
- Potrzebne zasoby i materia≈Çy
- Status zada≈Ñ i obecny postƒôp
- ZwiƒÖzki z zam√≥wieniami klient√≥w i recepturami
- Efektywno≈õƒá i czas realizacji zada≈Ñ
- Zarezerwowane partie materia≈Ç√≥w (LOTy) dla danego zlecenia
- PowiƒÖzania partii materia≈Ç√≥w z zam√≥wieniami zakupowymi (PO)
- Zgodno≈õƒá z wymogami jako≈õci dla produkcji suplement√≥w

Dla zam√≥wie≈Ñ klient√≥w (CO), analizuj:
- Statusy i terminowo≈õƒá realizacji
- Warto≈õci zam√≥wie≈Ñ i mar≈ºe
- Produkty najczƒô≈õciej zamawiane
- Relacje z klientami i trendy zam√≥wie≈Ñ
- PowiƒÖzania z zadaniami produkcyjnymi

Dla zam√≥wie≈Ñ zakupu (PO), analizuj:
- Dostawc√≥w i warunki zakup√≥w
- Terminy dostaw i ich dotrzymywanie
- Statusy zam√≥wie≈Ñ i etapy realizacji
- Warto≈õci zam√≥wie≈Ñ i koszty materia≈Ç√≥w
- Wp≈Çyw na stany magazynowe
- PowiƒÖzane LOTy materia≈Ç√≥w zakupionych w ramach zam√≥wienia
- Certyfikaty jako≈õci i dokumentacjƒô surowc√≥w do produkcji suplement√≥w

Dla stan√≥w magazynowych, identyfikuj:
- Produkty z niskim stanem lub brakiem
- Produkty z nadmiernym stanem
- Koszty utrzymania zapas√≥w
- Lokalizacje magazynowe
- Surowce wymagajƒÖce uzupe≈Çnienia
- Partie materia≈Ç√≥w (LOTy) i ich ilo≈õci
- ≈πr√≥d≈Ço pochodzenia partii (zam√≥wienie zakupowe)
- Daty wa≈ºno≈õci surowc√≥w i gotowych suplement√≥w
- Status kontroli jako≈õci dla partii surowc√≥w

Dla receptur, analizuj:
- Komponenty i ich ilo≈õci
- Koszty produkcji
- Mo≈ºliwo≈õci optymalizacji
- Standardy jako≈õci i kontrolƒô
- Zgodno≈õƒá z normami dla suplement√≥w diety
- Wymogi prawne dotyczƒÖce sk≈Çadu i etykietowania

Masz teraz rozszerzony dostƒôp do danych o partiach materia≈Ç√≥w i ich powiƒÖzaniach:
- Informacje o LOTach (numerach partii) materia≈Ç√≥w
- Dane o powiƒÖzanych zam√≥wieniach zakupowych (PO) dla ka≈ºdej partii
- Rezerwacje partii materia≈Ç√≥w dla zada≈Ñ produkcyjnych (MO)
- ≈öledzenie przep≈Çywu materia≈Ç√≥w od zam√≥wienia zakupowego do zadania produkcyjnego
- Status bada≈Ñ laboratoryjnych dla partii surowc√≥w i wyrob√≥w gotowych

Gdy otrzymasz zapytanie o powiƒÖzania LOT√≥w z zam√≥wieniami zakupowymi, analizuj:
- Kt√≥re partie materia≈Ç√≥w sƒÖ przypisane do jakich zada≈Ñ produkcyjnych
- Z kt√≥rego zam√≥wienia zakupowego pochodzi dana partia materia≈Çu
- Poziom wykorzystania zam√≥wionych materia≈Ç√≥w w produkcji
- Poprawno≈õƒá rezerwacji materia≈Ç√≥w i zgodno≈õƒá z recepturami
- Dokumentacjƒô jako≈õciowƒÖ dla partii

Zawsze podawaj DOK≈ÅADNE dane liczbowe bez zaokrƒÖgle≈Ñ, chyba ≈ºe jest to wyra≈∫nie wymagane. Podawaj procentowe por√≥wnania i uwzglƒôdniaj trendy, je≈õli sƒÖ widoczne.
Pamiƒôtaj o podawaniu konkretnych nazw zamiast samych ID. Format powinien byƒá: "Nazwa (ID: xxx)", gdy odno≈õisz siƒô do konkretnych obiekt√≥w.

Masz pe≈Çny dostƒôp do bazy danych Firebase i mo≈ºesz korzystaƒá z wszystkich danych zawartych w systemie MRP.
Zawsze podawaj aktualne informacje na podstawie danych z bazy, a nie og√≥lnej wiedzy.

UWAGA: Je≈õli w Twojej odpowiedzi chcesz wspomnieƒá o ograniczeniach dostƒôpu do danych, powiedz np. "Na podstawie obecnie dostƒôpnych danych nie mogƒô podaƒá tych informacji" - ale NIGDY nie m√≥w ≈ºe "nie masz mo≈ºliwo≈õci bezpo≈õredniego przeglƒÖdania danych".

Struktura danych w Firebase to:
- aiConversations - Przechowuje historiƒô konwersacji z asystentem AI
- counters - Liczniki u≈ºywane przez system
- customers - Dane klient√≥w firmy
- inventory - Stany magazynowe produkt√≥w
- inventoryBatches - Partie magazynowe produkt√≥w
- inventorySupplierPrices - Ceny produkt√≥w od dostawc√≥w
- inventoryTransactions - Transakcje magazynowe
- itemGroups - Grupy produkt√≥w
- notifications - Powiadomienia systemowe
- orders (CO) - Zam√≥wienia klient√≥w
- priceListItems - Elementy cennik√≥w
- priceLists - Cenniki
- productionHistory - Historia produkcji
- productionTasks (MO) - Zadania produkcyjne
- purchaseOrders (PO) - Zam√≥wienia zakupu
- recipeVersions - Wersje receptur
- recipes - Receptury produkt√≥w
- settings - Ustawienia systemu
- suppliers - Dostawcy
- users - U≈ºytkownicy systemu
- warehouses - Magazyny
- workstations - Stanowiska pracy
  `;
  
  let systemContent = systemPrompt;
  
  // Dodaj kontekst biznesowy, je≈õli jest dostƒôpny
  if (businessDataContext) {
    systemContent += `\n\nOto aktualne dane z systemu MRP do wykorzystania w analizie:${businessDataContext}`;
  }
  
  const systemInstruction = {
    role: 'system',
    content: systemContent
  };
  
  // Limitujemy liczbƒô wiadomo≈õci do MAX_CONTEXT_MESSAGES ostatnich
  const recentMessages = messages.slice(-MAX_CONTEXT_MESSAGES);
  
  // Formatowanie wiadomo≈õci do formatu wymaganego przez API OpenAI
  const formattedMessages = recentMessages.map(msg => ({
    role: msg.role,
    content: msg.content
  }));
  
  return [systemInstruction, ...formattedMessages];
};

/**
 * WyciƒÖga nazwƒô receptury z zapytania u≈ºytkownika
 * @param {string} query - Zapytanie u≈ºytkownika
 * @returns {string|null} - Znaleziona nazwa receptury lub null
 */
const extractRecipeName = (query) => {
  // Sprawd≈∫, czy query istnieje i jest stringiem
  if (!query || typeof query !== 'string') {
    return null;
  }
  
  // Wzorce do rozpoznawania zapyta≈Ñ o konkretne receptury
  const patterns = [
    /receptur[aƒôy][\s\w]*"([^"]+)"/i,       // receptura "nazwa"
    /receptur[aƒôy][\s\w]*‚Äû([^"]+)"/i,        // receptura ‚Äûnazwa"
    /receptur[aƒôy][\s\w]+([a-z≈º≈∫ƒá≈Ñ√≥≈ÇƒôƒÖ≈õ]{3,})/i,  // receptura nazwa
    /przepis[\s\w]+([a-z≈º≈∫ƒá≈Ñ√≥≈ÇƒôƒÖ≈õ]{3,})/i,   // przepis nazwa
    /receptur[aƒôy][\s\w]+dla[\s\w]+([a-z≈º≈∫ƒá≈Ñ√≥≈ÇƒôƒÖ≈õ]{3,})/i, // receptura dla nazwa
    /receptur[aƒôy][\s\w]+produktu[\s\w]+([a-z≈º≈∫ƒá≈Ñ√≥≈ÇƒôƒÖ≈õ]{3,})/i // receptura produktu nazwa
  ];
  
  for (const pattern of patterns) {
    const match = query.match(pattern);
    if (match && match[1] && match[1].length > 2) {
      return match[1].trim();
    }
  }
  
  return null;
};

// Definicja funkcji getMockResponse
    if (businessData.data && businessData.data.inventoryTransactions && 
        businessData.data.inventoryTransactions.length > 0) {
      
      businessDataContext += `\n### Dane o transakcjach magazynowych (inventoryTransactions):\n`;
      businessDataContext += `Liczba transakcji: ${businessData.data.inventoryTransactions.length}\n`;
      
      // Przyk≈Çadowe transakcje magazynowe
      businessDataContext += `\nOstatnie transakcje magazynowe:\n`;
      businessData.data.inventoryTransactions.slice(0, 5).forEach((transaction, index) => {
        businessDataContext += `${index + 1}. ID: ${transaction.id}, Typ: ${transaction.type || 'Nieznany'}, Produkt: ${transaction.itemId || 'Nieznany'}, Ilo≈õƒá: ${transaction.quantity || 0}, Data: ${transaction.date || 'Nieznana'}\n`;
      });
    }
    
    // Dodaj dane o powiadomieniach, je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.notifications && 
        businessData.data.notifications.length > 0) {
      
      businessDataContext += `\n### Dane o powiadomieniach (notifications):\n`;
      businessDataContext += `Liczba powiadomie≈Ñ: ${businessData.data.notifications.length}\n`;
      
      // Przyk≈Çadowe powiadomienia
      businessDataContext += `\nOstatnie powiadomienia:\n`;
      businessData.data.notifications.slice(0, 5).forEach((notification, index) => {
        businessDataContext += `${index + 1}. ID: ${notification.id}, Tytu≈Ç: ${notification.title || 'Bez tytu≈Çu'}, Typ: ${notification.type || 'Informacja'}, Data: ${notification.createdAt || 'Nieznana'}\n`;
      });
    }
    
    // Dodaj dane o elementach cennik√≥w, je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.priceListItems && 
        businessData.data.priceListItems.length > 0) {
      
      businessDataContext += `\n### Dane o elementach cennik√≥w (priceListItems):\n`;
      businessDataContext += `Liczba element√≥w: ${businessData.data.priceListItems.length}\n`;
      
      // Przyk≈Çadowe elementy cennik√≥w
      businessDataContext += `\nPrzyk≈Çadowe elementy cennik√≥w:\n`;
      businessData.data.priceListItems.slice(0, 5).forEach((item, index) => {
        businessDataContext += `${index + 1}. ID: ${item.id}, Produkt: ${item.productId || 'Nieznany'}, Cennik: ${item.priceListId || 'Nieznany'}, Cena: ${item.price || 0} ${item.currency || 'PLN'}\n`;
      });
    }
    
    // Dodaj dane o cennikach, je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.priceLists && 
        businessData.data.priceLists.length > 0) {
      
      businessDataContext += `\n### Dane o cennikach (priceLists):\n`;
      businessDataContext += `Liczba cennik√≥w: ${businessData.data.priceLists.length}\n`;
      
      // Przyk≈Çadowe cenniki
      businessDataContext += `\nPrzyk≈Çadowe cenniki:\n`;
      businessData.data.priceLists.slice(0, 5).forEach((priceList, index) => {
        businessDataContext += `${index + 1}. ID: ${priceList.id}, Nazwa: ${priceList.name || 'Bez nazwy'}, Waluta: ${priceList.currency || 'PLN'}, Aktywny: ${priceList.active ? 'Tak' : 'Nie'}\n`;
      });
    }
    
    // Dodaj dane o historii produkcji, je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.productionHistory && 
        businessData.data.productionHistory.length > 0) {
      
      businessDataContext += `\n### Dane o historii produkcji (productionHistory):\n`;
      businessDataContext += `Liczba wpis√≥w: ${businessData.data.productionHistory.length}\n`;
      
      // Przyk≈Çadowe wpisy historii produkcji
      businessDataContext += `\nOstatnie wpisy historii produkcji:\n`;
      businessData.data.productionHistory.slice(0, 5).forEach((history, index) => {
        businessDataContext += `${index + 1}. ID: ${history.id}, Zadanie: ${history.taskId || 'Nieznane'}, Typ: ${history.eventType || 'Nieznany'}, Data: ${history.timestamp || 'Nieznana'}\n`;
      });
    }
    
    // Dodaj dane o wersjach receptur, je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.recipeVersions && 
        businessData.data.recipeVersions.length > 0) {
      
      businessDataContext += `\n### Dane o wersjach receptur (recipeVersions):\n`;
      businessDataContext += `Liczba wersji: ${businessData.data.recipeVersions.length}\n`;
      
      // Przyk≈Çadowe wersje receptur
      businessDataContext += `\nPrzyk≈Çadowe wersje receptur:\n`;
      businessData.data.recipeVersions.slice(0, 5).forEach((version, index) => {
        businessDataContext += `${index + 1}. ID: ${version.id}, Receptura: ${version.recipeId || 'Nieznana'}, Wersja: ${version.version || '1.0'}, Data: ${version.createdAt || 'Nieznana'}\n`;
      });
    }
    
    // Dodaj dane o ustawieniach systemu, je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.settings && 
        businessData.data.settings.length > 0) {
      
      businessDataContext += `\n### Dane o ustawieniach systemu (settings):\n`;
      businessDataContext += `Liczba ustawie≈Ñ: ${businessData.data.settings.length}\n`;
      
      // Przyk≈Çadowe ustawienia
      businessDataContext += `\nPrzyk≈Çadowe ustawienia systemu:\n`;
      businessData.data.settings.slice(0, 5).forEach((setting, index) => {
        businessDataContext += `${index + 1}. ID: ${setting.id}, Klucz: ${setting.key || 'Nieznany'}, Warto≈õƒá: ${setting.value || 'Nieznana'}\n`;
      });
    }
    
    // Dodaj dane o u≈ºytkownikach, je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.users && 
        businessData.data.users.length > 0) {
      
      businessDataContext += `\n### Dane o u≈ºytkownikach (users):\n`;
      businessDataContext += `Liczba u≈ºytkownik√≥w: ${businessData.data.users.length}\n`;
      
      // Przyk≈Çadowi u≈ºytkownicy (bez danych wra≈ºliwych)
      businessDataContext += `\nPrzyk≈Çadowi u≈ºytkownicy:\n`;
      businessData.data.users.slice(0, 5).forEach((user, index) => {
        businessDataContext += `${index + 1}. ID: ${user.id}, Rola: ${user.role || 'U≈ºytkownik'}, Aktywny: ${user.active ? 'Tak' : 'Nie'}\n`;
      });
    }
    
    // Dodaj dane o magazynach, je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.warehouses && 
        businessData.data.warehouses.length > 0) {
      
      businessDataContext += `\n### Dane o magazynach (warehouses):\n`;
      businessDataContext += `Liczba magazyn√≥w: ${businessData.data.warehouses.length}\n`;
      
      // Przyk≈Çadowe magazyny
      businessDataContext += `\nPrzyk≈Çadowe magazyny:\n`;
      businessData.data.warehouses.slice(0, 5).forEach((warehouse, index) => {
        businessDataContext += `${index + 1}. ID: ${warehouse.id}, Nazwa: ${warehouse.name || 'Bez nazwy'}, Adres: ${warehouse.address || 'Brak adresu'}\n`;
      });
    }
    
    // Dodaj dane o stanowiskach pracy, je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.workstations && 
        businessData.data.workstations.length > 0) {
      
      businessDataContext += `\n### Dane o stanowiskach pracy (workstations):\n`;
      businessDataContext += `Liczba stanowisk: ${businessData.data.workstations.length}\n`;
      
      // Przyk≈Çadowe stanowiska pracy
      businessDataContext += `\nPrzyk≈Çadowe stanowiska pracy:\n`;
      businessData.data.workstations.slice(0, 5).forEach((workstation, index) => {
        businessDataContext += `${index + 1}. ID: ${workstation.id}, Nazwa: ${workstation.name || 'Bez nazwy'}, Typ: ${workstation.type || 'Standardowe'}, Status: ${workstation.status || 'Aktywne'}\n`;
      });
    }
    
    // Dodaj dane o partiach magazynowych (InventoryBatches), je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.inventoryBatches && 
        businessData.data.inventoryBatches.length > 0) {
      
      businessDataContext += `\n### Dane o partiach magazynowych (InventoryBatches):\n`;
      businessDataContext += `Liczba partii magazynowych: ${businessData.data.inventoryBatches.length}\n`;
      
      // Przyk≈Çadowe partie magazynowe
      businessDataContext += `\nPrzyk≈Çadowe partie magazynowe:\n`;
      businessData.data.inventoryBatches.slice(0, 5).forEach((batch, index) => {
        businessDataContext += `${index + 1}. ID: ${batch.id}, Numer partii: ${batch.batchNumber || 'Bez numeru'}, Produkt: ${batch.itemId || batch.productId || 'Nieznany'}\n`;
        if (batch.quantity) {
          businessDataContext += `   Ilo≈õƒá: ${batch.quantity} ${batch.unit || 'szt.'}\n`;
        }
        if (batch.expiryDate) {
          businessDataContext += `   Data wa≈ºno≈õci: ${batch.expiryDate}\n`;
        }
        if (batch.supplier) {
          businessDataContext += `   Dostawca: ${batch.supplier}\n`;
        }
      });
      
      // Statystyki partii magazynowych
      const expiredBatches = businessData.data.inventoryBatches.filter(batch => {
        if (!batch.expiryDate) return false;
        const expiryDate = new Date(batch.expiryDate);
        return expiryDate < new Date();
      }).length;
      
      if (expiredBatches > 0) {
        businessDataContext += `\nLiczba przeterminowanych partii: ${expiredBatches}\n`;
      }
      
      const totalQuantity = businessData.data.inventoryBatches.reduce((sum, batch) => {
        return sum + (parseFloat(batch.quantity) || 0);
      }, 0);
      
      businessDataContext += `≈ÅƒÖczna ilo≈õƒá we wszystkich partiach: ${totalQuantity.toFixed(2)}\n`;
    }
    
    // Teraz kontynuuj z istniejƒÖcymi ju≈º blokami kodu dla innych kolekcji
    
    // Dodaj dane o klientach, gdy sƒÖ dostƒôpne
    if (businessData.data && businessData.data.customers && 
        businessData.data.customers.length > 0) {
      
      businessDataContext += `\n### Dane o klientach (Customers):\n`;
      const customers = businessData.data.customers;
      businessDataContext += `Liczba pobranych klient√≥w: ${customers.length}\n`;
      
      businessDataContext += `\nLista klient√≥w (do 10 pierwszych):\n`;
      const customerList = customers.slice(0, 10);
      customerList.forEach((customer, index) => {
        businessDataContext += `${index + 1}. ID: ${customer.id}, Nazwa: ${customer.name || 'Nieznany klient'}`;
        if (customer.email) {
          businessDataContext += `, Email: ${customer.email}`;
        }
        if (customer.phone) {
          businessDataContext += `, Telefon: ${customer.phone}`;
        }
        businessDataContext += `\n`;
      });
    }
    
    // Dodaj dane o produkcji zawsze, gdy sƒÖ dostƒôpne
    if (businessData.data && businessData.data.productionTasks && 
        businessData.data.productionTasks.length > 0) {
      
      businessDataContext += `\n### Dane o zadaniach produkcyjnych (MO - Manufacturing Orders):\n`;
      const tasks = businessData.data.productionTasks;
      businessDataContext += `Liczba pobranych zada≈Ñ: ${tasks.length}\n`;
      
      // Dodaj statystyki status√≥w
      if (businessData.analysis && businessData.analysis.production && 
          businessData.analysis.production.tasksByStatus) {
        businessDataContext += `\nStatusy zada≈Ñ:\n`;
        const statuses = businessData.analysis.production.tasksByStatus;
        Object.keys(statuses).forEach(status => {
          businessDataContext += `- ${status}: ${statuses[status]}\n`;
        });
      }
      
      // Dodaj szczeg√≥≈Çy dotyczƒÖce aktywnych zada≈Ñ
      const activeTasks = tasks.filter(task => 
        task.status !== 'completed' && task.status !== 'cancelled' && 
        task.status !== 'Zako≈Ñczone' && task.status !== 'Anulowane'
      ).slice(0, 10); // Zwiƒôkszono liczbƒô wy≈õwietlanych zada≈Ñ
      
      if (activeTasks.length > 0) {
        businessDataContext += `\nAktywne zadania produkcyjne (MO):\n`;
        activeTasks.forEach((task, index) => {
          businessDataContext += `${index + 1}. ID: ${task.id}, Nazwa: ${task.name || task.productName || `Zadanie #${task.id}`} - `;
          businessDataContext += `status: ${task.status || 'nieznany'}`;
          
          if (task.scheduledDate) {
            const startDate = task.scheduledDate.toDate ? task.scheduledDate.toDate() : new Date(task.scheduledDate);
            businessDataContext += `, planowane rozpoczƒôcie: ${startDate.toLocaleDateString('pl-PL')}`;
          }
          
          if (task.endDate) {
            const endDate = task.endDate.toDate ? task.endDate.toDate() : new Date(task.endDate);
            businessDataContext += `, planowane zako≈Ñczenie: ${endDate.toLocaleDateString('pl-PL')}`;
          }
          
          if (task.startDate) {
            const actualStartDate = task.startDate.toDate ? task.startDate.toDate() : new Date(task.startDate);
            businessDataContext += `, rzeczywiste rozpoczƒôcie: ${actualStartDate.toLocaleDateString('pl-PL')}`;
          }
          
          if (task.quantity) {
            businessDataContext += `, ilo≈õƒá: ${task.quantity}`;
          }
          
          if (task.orderNumber || task.productionOrder) {
            businessDataContext += `, nr zlecenia: ${task.orderNumber || task.productionOrder || 'N/A'}`;
          }
          
          businessDataContext += `\n`;
        });
      }
      
      // Dodaj informacje o czasie produkcji
      businessDataContext += `\n### Informacje o czasie produkcji:\n`;
      
      // Sprawd≈∫, czy mamy czas produkcji w recepturach
      if (businessData.data && businessData.data.recipes && businessData.data.recipes.length > 0) {
        const recipesWithProductionTime = businessData.data.recipes.filter(recipe => 
          recipe.productionTimePerUnit && parseFloat(recipe.productionTimePerUnit) > 0
        );
        
        if (recipesWithProductionTime.length > 0) {
          businessDataContext += `Receptury z okre≈õlonym czasem produkcji:\n`;
          recipesWithProductionTime.slice(0, 5).forEach((recipe, index) => {
            businessDataContext += `${index + 1}. ${recipe.name}: ${parseFloat(recipe.productionTimePerUnit).toFixed(2)} minut/szt.\n`;
          });
          
          // Przyk≈Çadowe obliczenie czasu produkcji
          const sampleRecipe = recipesWithProductionTime[0];
          const sampleQuantity = 100;
          const totalTime = parseFloat(sampleRecipe.productionTimePerUnit) * sampleQuantity;
          
          businessDataContext += `\nPrzyk≈Çad obliczenia czasu produkcji:\n`;
          businessDataContext += `Dla receptury "${sampleRecipe.name}" wyprodukowanie ${sampleQuantity} szt. zajmie ${totalTime.toFixed(2)} minut (${(totalTime/60).toFixed(2)} godzin).\n`;
          
          // Informacja o interpretacji czasu produkcji
          businessDataContext += `\nInterpretacja czasu produkcji:\n`;
          businessDataContext += `- Ka≈ºda receptura mo≈ºe mieƒá okre≈õlony parametr productionTimePerUnit, kt√≥ry okre≈õla czas produkcji jednostki produktu w minutach\n`;
          businessDataContext += `- Ca≈Çkowity czas produkcji = productionTimePerUnit * ilo≈õƒá produktu\n`;
          businessDataContext += `- Czas podany jest w minutach, mo≈ºna przeliczyƒá na godziny dzielƒÖc przez 60\n`;
        } else {
          businessDataContext += `Brak receptur z okre≈õlonym czasem produkcji w dostƒôpnych danych.\n`;
        }
      }
      
      // Dodaj szczeg√≥≈Çy dotyczƒÖce zako≈Ñczonych zada≈Ñ
      if (businessData.analysis && 
          businessData.analysis.production && 
          businessData.analysis.production.completedTasks) {
        
        const completedTasks = businessData.analysis.production.completedTasks;
        const stats = businessData.analysis.production.completedTasksStats;
        
        businessDataContext += `\nZako≈Ñczone zadania produkcyjne (MO):\n`;
        businessDataContext += `Liczba zako≈Ñczonych zada≈Ñ: ${stats?.count || completedTasks.length}\n`;
        
        if (stats && stats.avgDuration) {
          businessDataContext += `≈öredni czas trwania: ${stats.avgDuration.toFixed(2)} h\n`;
        }
        
        if (stats && stats.totalQuantity) {
          businessDataContext += `≈ÅƒÖczna wyprodukowana ilo≈õƒá: ${stats.totalQuantity}\n`;
        }
        
        businessDataContext += `\nOstatnie zako≈Ñczone zadania:\n`;
        
        // Wy≈õwietl najnowsze zako≈Ñczone zadania
        const recentTasks = businessData.analysis.production.recentlyCompletedTasks || 
                           completedTasks.slice(0, 8);
        
        recentTasks.forEach((task, index) => {
          businessDataContext += `${index + 1}. ID: ${task.id}, ${task.name} - `;
          if (task.endDate) {
            const endDate = new Date(task.endDate);
            businessDataContext += `zako≈Ñczone: ${endDate.toLocaleDateString('pl-PL')}`;
          } else {
            businessDataContext += `zako≈Ñczone`;
          }
          
          if (task.quantity) {
            businessDataContext += `, ilo≈õƒá: ${task.quantity}`;
          }
          
          if (task.duration) {
            businessDataContext += `, czas: ${task.duration} h`;
          }
          
          businessDataContext += `\n`;
        });
      }
    }
    
    // Dodaj dane o recepturach zawsze, gdy sƒÖ dostƒôpne
    if (businessData.data && businessData.data.recipes && 
        businessData.data.recipes.length > 0) {
      
      businessDataContext += `\n### Dane o recepturach:\n`;
      const recipes = businessData.data.recipes;
      businessDataContext += `Liczba receptur: ${recipes.length}\n`;
      
      // Dodaj statystyki receptur
      if (businessData.analysis && businessData.analysis.recipes) {
        const recipesAnalysis = businessData.analysis.recipes;
        
        if (recipesAnalysis.recipesWithComponents > 0) {
          businessDataContext += `Receptury z komponentami: ${recipesAnalysis.recipesWithComponents}\n`;
          businessDataContext += `≈örednia liczba komponent√≥w na recepturƒô: ${recipesAnalysis.avgComponentsPerRecipe.toFixed(1)}\n`;
          businessDataContext += `Liczba unikalnych komponent√≥w we wszystkich recepturach: ${recipesAnalysis.uniqueComponentsCount || 0}\n`;
          
          // Dodaj informacje o najczƒô≈õciej u≈ºywanych komponentach
          if (recipesAnalysis.topComponents && recipesAnalysis.topComponents.length > 0) {
            businessDataContext += `\nNajczƒô≈õciej u≈ºywane komponenty:\n`;
            recipesAnalysis.topComponents.slice(0, 5).forEach((comp, idx) => {
              businessDataContext += `${idx + 1}. ${comp.name} - u≈ºywany w ${comp.usageCount} recepturach\n`;
            });
          }
        }
        
        // Wy≈õwietl informacje o wszystkich recepturach z pe≈Çnymi szczeg√≥≈Çami
        if (recipesAnalysis.fullRecipeDetails && recipesAnalysis.fullRecipeDetails.length > 0) {
          businessDataContext += `\n### Pe≈Çna lista wszystkich receptur z komponentami:\n`;
          
          recipesAnalysis.fullRecipeDetails.forEach((recipe, index) => {
            businessDataContext += `\n${index + 1}. Receptura: ${recipe.name}\n`;
            businessDataContext += `   - ID: ${recipe.id}\n`;
            businessDataContext += `   - Produkt: ${recipe.product}\n`;
            businessDataContext += `   - Jednostka: ${recipe.unit}\n`;
            if (recipe.description) {
              businessDataContext += `   - Opis: ${recipe.description}\n`;
            }
            if (recipe.customerId) {
              businessDataContext += `   - Klient: ${recipe.customerName || recipe.customerId}\n`;
            }
            
            const componentsCount = recipe.components?.length || 0;
            const ingredientsCount = recipe.ingredients?.length || 0;
            
            // Poka≈º komponenty receptury
            if (componentsCount > 0) {
              businessDataContext += `   - Komponenty (${componentsCount}):\n`;
              recipe.components.forEach((comp, idx) => {
                businessDataContext += `     * ${comp.name}: ${comp.quantity} ${comp.unit}${comp.notes ? ` (${comp.notes})` : ''}\n`;
              });
            }
            
            // Poka≈º sk≈Çadniki receptury
            if (ingredientsCount > 0) {
              businessDataContext += `   - Sk≈Çadniki (${ingredientsCount}):\n`;
              recipe.ingredients.forEach((ing, idx) => {
                businessDataContext += `     * ${ing.name}: ${ing.quantity} ${ing.unit}${ing.notes ? ` (${ing.notes})` : ''}\n`;
              });
            }
            
            if (componentsCount === 0 && ingredientsCount === 0) {
              businessDataContext += `   - Brak zdefiniowanych komponent√≥w i sk≈Çadnik√≥w\n`;
            }
            
            // Dodatkowe informacje
            if (recipe.notes) {
              businessDataContext += `   - Uwagi: ${recipe.notes}\n`;
            }
            
            businessDataContext += `   - Status: ${recipe.status}\n`;
            businessDataContext += `   - Wersja: ${recipe.version}\n`;
          });
        }
        
        // Je≈õli zapytanie dotyczy konkretnej receptury, poka≈º szczeg√≥≈Çy
        const recipeName = businessData.query && typeof businessData.query === 'string' ? extractRecipeName(businessData.query) : null;
        if (recipeName) {
          const recipe = recipes.find(r => 
            r.name.toLowerCase().includes(recipeName.toLowerCase())
          );
          
          if (recipe) {
            businessDataContext += `\n### Szczeg√≥≈Çy receptury "${recipe.name}":\n`;
            businessDataContext += `Produkt wyj≈õciowy: ${recipe.productName || recipe.product?.name || 'Nieznany'}\n`;
            businessDataContext += `Jednostka: ${recipe.unit || 'szt.'}\n`;
            
            // Sprawd≈∫ zar√≥wno pole components jak i ingredients
            const hasComponents = recipe.components && recipe.components.length > 0;
            const hasIngredients = recipe.ingredients && recipe.ingredients.length > 0;
            
            if (hasComponents) {
              businessDataContext += `\nKomponenty (${recipe.components.length}):\n`;
              recipe.components.forEach((component, idx) => {
                businessDataContext += `- ${component.name || component.materialName || `Komponent ${idx+1}`}: ${component.quantity || 1} ${component.unit || 'szt.'}\n`;
              });
            } else if (hasIngredients) {
              businessDataContext += `\nSk≈Çadniki (${recipe.ingredients.length}):\n`;
              recipe.ingredients.forEach((ingredient, idx) => {
                businessDataContext += `- ${ingredient.name || `Sk≈Çadnik ${idx+1}`}: ${ingredient.quantity || 1} ${ingredient.unit || 'szt.'}\n`;
              });
            } else {
              businessDataContext += `\nTa receptura nie ma zdefiniowanych komponent√≥w ani sk≈Çadnik√≥w.\n`;
            }
          }
        }
      }
    }
    
    // Dodaj dane o magazynie zawsze, gdy sƒÖ dostƒôpne
    if (businessData.data && businessData.data.inventory && 
        businessData.data.inventory.length > 0) {
      
      businessDataContext += `\n### Dane o stanie magazynowym:\n`;
      businessDataContext += `Liczba produkt√≥w: ${businessData.data.inventory.length}\n`;
      
      // Dodaj informacje o produktach z niskim stanem
      if (businessData.analysis && businessData.analysis.inventory) {
        const inventory = businessData.analysis.inventory;
        
        if (inventory.lowStockItems && inventory.lowStockItems.length > 0) {
          businessDataContext += `\nProdukty z niskim stanem (${inventory.lowStockItems.length}):\n`;
          inventory.lowStockItems.slice(0, 10).forEach((item, index) => {
            businessDataContext += `- ${item.name}: ${item.quantity} szt. (min: ${item.minQuantity})\n`;
          });
          
          if (inventory.lowStockItems.length > 10) {
            businessDataContext += `... i ${inventory.lowStockItems.length - 10} wiƒôcej\n`;
          }
        }
        
        if (inventory.outOfStockItems && inventory.outOfStockItems.length > 0) {
          businessDataContext += `\nProdukty niedostƒôpne (${inventory.outOfStockItems.length}):\n`;
          inventory.outOfStockItems.slice(0, 10).forEach((item, index) => {
            businessDataContext += `- ${item.name}\n`;
          });
          
          if (inventory.outOfStockItems.length > 10) {
            businessDataContext += `... i ${inventory.outOfStockItems.length - 10} wiƒôcej\n`;
          }
        }
        
        // Dodaj informacje o produktach z nadmiernym stanem
        if (inventory.overStockItems && inventory.overStockItems.length > 0) {
          businessDataContext += `\nProdukty z nadmiernym stanem (${inventory.overStockItems.length}):\n`;
          inventory.overStockItems.slice(0, 5).forEach((item, index) => {
            businessDataContext += `- ${item.name}: ${item.quantity} szt. (max: ${item.maxQuantity})\n`;
          });
          
          if (inventory.overStockItems.length > 5) {
            businessDataContext += `... i ${inventory.overStockItems.length - 5} wiƒôcej\n`;
          }
        }
        
        // Dodaj przyk≈Çady produkt√≥w z normalnym stanem
        const normalStockItems = businessData.data.inventory.filter(item => 
          item.quantity > (item.minQuantity || 0) && 
          (!item.maxQuantity || item.quantity <= item.maxQuantity)
        ).slice(0, 5);
        
        if (normalStockItems.length > 0) {
          businessDataContext += `\nPrzyk≈Çadowe produkty z normalnym stanem:\n`;
          normalStockItems.forEach((item, index) => {
            businessDataContext += `- ${item.name}: ${item.quantity} ${item.unit || 'szt.'}\n`;
          });
        }
      }
    }
    
    // Dodaj dane o zam√≥wieniach klient√≥w zawsze, gdy sƒÖ dostƒôpne
    if (businessData.data && businessData.data.orders && 
        businessData.data.orders.length > 0) {
      
      businessDataContext += `\n### Dane o zam√≥wieniach klient√≥w (CO - Customer Orders):\n`;
      businessDataContext += `Liczba zam√≥wie≈Ñ: ${businessData.data.orders.length}\n`;
      
      // Dodaj statystyki status√≥w zam√≥wie≈Ñ klient√≥w
      if (businessData.analysis && businessData.analysis.orders && 
          businessData.analysis.orders.ordersByStatus) {
        businessDataContext += `\nStatusy zam√≥wie≈Ñ klient√≥w:\n`;
        const statuses = businessData.analysis.orders.ordersByStatus;
        Object.keys(statuses).forEach(status => {
          businessDataContext += `- ${status}: ${statuses[status]}\n`;
        });
      }
      
      // Wy≈õwietl szczeg√≥≈Çy zam√≥wie≈Ñ klient√≥w
      if (businessData.analysis && businessData.analysis.orders) {
        const orders = businessData.analysis.orders;
        
        if (orders.totalValue) {
          businessDataContext += `\n≈ÅƒÖczna warto≈õƒá zam√≥wie≈Ñ: ${orders.totalValue.toFixed(2)} PLN\n`;
        }
        
        if (orders.averageOrderValue) {
          businessDataContext += `≈örednia warto≈õƒá zam√≥wienia: ${orders.averageOrderValue.toFixed(2)} PLN\n`;
        }
        
        // Ostatnie zam√≥wienia
        if (orders.recentOrders && orders.recentOrders.length > 0) {
          businessDataContext += `\nOstatnie zam√≥wienia klient√≥w (CO):\n`;
          orders.recentOrders.forEach((order, index) => {
            businessDataContext += `${index + 1}. ID: ${order.id}, Klient: ${order.customer}, Status: ${order.status}, Data: ${order.date}, Warto≈õƒá: ${order.value} PLN\n`;
          });
        }
      }
      
      // Dodaj informacje o aktywnych zam√≥wieniach
      const activeOrders = businessData.data.orders.filter(order => 
        order.status !== 'completed' && order.status !== 'cancelled' && 
        order.status !== 'Zako≈Ñczone' && order.status !== 'Anulowane'
      ).slice(0, 10); // Zwiƒôkszono liczbƒô wy≈õwietlanych zam√≥wie≈Ñ
      
      if (activeOrders.length > 0) {
        businessDataContext += `\nSzczeg√≥≈Çy aktywnych zam√≥wie≈Ñ klient√≥w (CO):\n`;
        activeOrders.forEach((order, index) => {
          businessDataContext += `${index + 1}. ID: ${order.id}, Klient: ${order.customerName || 'Nieznany'}, Status: ${order.status || 'nieznany'}\n`;
          if (order.items && order.items.length > 0) {
            businessDataContext += `   Pozycje:\n`;
            order.items.slice(0, 5).forEach(item => { // Zwiƒôkszono liczbƒô pozycji
              businessDataContext += `   - ${item.name || 'Pozycja'}: ${item.quantity} ${item.unit || 'szt.'}, ${item.price ? `cena: ${item.price} PLN` : ''}\n`;
            });
            if (order.items.length > 5) {
              businessDataContext += `   ... i ${order.items.length - 5} wiƒôcej pozycji\n`;
            }
          }
        });
      }
    }
    
    // Dodaj dane o dostawcach, je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.suppliers && 
        businessData.data.suppliers.length > 0) {
      
      businessDataContext += `\n### Dane o dostawcach:\n`;
      businessDataContext += `Liczba dostawc√≥w: ${businessData.data.suppliers.length}\n`;
      
      // Dodaj przyk≈Çady dostawc√≥w
      const topSuppliers = businessData.data.suppliers.slice(0, 8); // Zwiƒôkszono liczbƒô dostawc√≥w
      if (topSuppliers.length > 0) {
        businessDataContext += `\nPrzyk≈Çadowi dostawcy:\n`;
        topSuppliers.forEach((supplier, index) => {
          businessDataContext += `${index + 1}. ID: ${supplier.id}, Nazwa: ${supplier.name || 'Bez nazwy'}, Osoba: ${supplier.contactPerson || 'Brak'}\n`;
          if (supplier.email || supplier.phone) {
            businessDataContext += `   Kontakt: ${supplier.email || ''} ${supplier.phone ? ', tel: ' + supplier.phone : ''}\n`;
          }
          if (supplier.category) {
            businessDataContext += `   Kategoria: ${supplier.category}\n`;
          }
        });
      }
    }
    
    // Dodaj dane o zam√≥wieniach zakupu, je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.purchaseOrders && 
        businessData.data.purchaseOrders.length > 0) {
      
      businessDataContext += `\n### Dane o zam√≥wieniach zakupu (PO - Purchase Orders):\n`;
      businessDataContext += `Liczba zam√≥wie≈Ñ zakupu: ${businessData.data.purchaseOrders.length}\n`;
      
      // Dodaj statystyki status√≥w
      if (businessData.analysis && businessData.analysis.purchaseOrders && 
          businessData.analysis.purchaseOrders.poByStatus) {
        businessDataContext += `\nStatusy zam√≥wie≈Ñ zakupu:\n`;
        const statuses = businessData.analysis.purchaseOrders.poByStatus;
        Object.keys(statuses).forEach(status => {
          businessDataContext += `- ${status}: ${statuses[status]}\n`;
        });
      }
      
      // Dodaj warto≈õci zam√≥wie≈Ñ zakupu
      if (businessData.analysis && businessData.analysis.purchaseOrders) {
        const poAnalysis = businessData.analysis.purchaseOrders;
        
        if (poAnalysis.totalValue) {
          businessDataContext += `\n≈ÅƒÖczna warto≈õƒá zam√≥wie≈Ñ zakupu: ${poAnalysis.totalValue.toFixed(2)} PLN\n`;
        }
        
        if (poAnalysis.averagePOValue) {
          businessDataContext += `≈örednia warto≈õƒá zam√≥wienia zakupu: ${poAnalysis.averagePOValue.toFixed(2)} PLN\n`;
        }
      }
      
      // Szczeg√≥≈Çy bie≈ºƒÖcych zam√≥wie≈Ñ zakupu
      if (businessData.analysis && businessData.analysis.purchaseOrders && 
          businessData.analysis.purchaseOrders.currentPOs) {
        const currentPOs = businessData.analysis.purchaseOrders.currentPOs;
        
        if (currentPOs.length > 0) {
          businessDataContext += `\nBie≈ºƒÖce zam√≥wienia zakupu (PO):\n`;
          currentPOs.slice(0, 10).forEach((po, index) => { // Zwiƒôkszono liczbƒô zam√≥wie≈Ñ
            businessDataContext += `${index + 1}. ID: ${po.id}, Dostawca: ${po.supplier}, Status: ${po.status}\n`;
            businessDataContext += `   Data zam√≥wienia: ${po.orderDate || 'N/A'}, Oczekiwana dostawa: ${po.expectedDeliveryDate || 'N/A'}, Warto≈õƒá: ${po.totalValue.toFixed(2)} PLN\n`;
          });
          
          if (currentPOs.length > 10) {
            businessDataContext += `... i ${currentPOs.length - 10} wiƒôcej\n`;
          }
        }
      }
      
      // Szczeg√≥≈Çy wszystkich zam√≥wie≈Ñ zakupu
      const topPurchaseOrders = businessData.data.purchaseOrders.slice(0, 8); // Dodatkowe szczeg√≥≈Çy
      if (topPurchaseOrders.length > 0) {
        businessDataContext += `\nSzczeg√≥≈Çowe dane zam√≥wie≈Ñ zakupu (PO):\n`;
        topPurchaseOrders.forEach((po, index) => {
          businessDataContext += `${index + 1}. ID: ${po.id}, Dostawca: ${po.supplierName || po.supplier?.name || 'Nieznany'}, Status: ${po.status || 'nieznany'}\n`;
          
          if (po.items && po.items.length > 0) {
            businessDataContext += `   Pozycje zam√≥wienia:\n`;
            po.items.slice(0, 5).forEach(item => { // Zwiƒôkszono liczbƒô pozycji
              businessDataContext += `   - ${item.name || 'Pozycja'}: ${item.quantity} ${item.unit || 'szt.'} ${item.price ? `, cena: ${item.price} PLN` : ''}\n`;
            });
            if (po.items.length > 5) {
              businessDataContext += `   ... i ${po.items.length - 5} wiƒôcej pozycji\n`;
            }
          }
        });
      }
    }
    
    // Dodaj dane o partiach materia≈Ç√≥w (LOTach), je≈õli sƒÖ dostƒôpne
    if (businessData.data && businessData.data.materialBatches && 
        businessData.data.materialBatches.length > 0) {
      
      businessDataContext += `\n### Dane o partiach materia≈Ç√≥w (LOTach):\n`;
      businessDataContext += `Liczba partii materia≈Ç√≥w: ${businessData.data.materialBatches.length}\n`;
      
      // Dodaj analizƒô partii materia≈Ç√≥w, je≈õli jest dostƒôpna
      if (businessData.analysis && businessData.analysis.materialBatches) {
        const batchesAnalysis = businessData.analysis.materialBatches;
        
        if (batchesAnalysis.totalBatches) {
          businessDataContext += `\n≈ÅƒÖczna liczba partii: ${batchesAnalysis.totalBatches}\n`;
        }
        
        if (batchesAnalysis.batchesWithPO) {
          businessDataContext += `Partie z powiƒÖzanym zam√≥wieniem zakupu: ${batchesAnalysis.batchesWithPO}\n`;
        }
      }
      
      // Wy≈õwietl przyk≈Çadowe partie materia≈Ç√≥w
      const topBatches = businessData.data.materialBatches.slice(0, 10);
      if (topBatches.length > 0) {
        businessDataContext += `\nPrzyk≈Çadowe partie materia≈Ç√≥w:\n`;
        topBatches.forEach((batch, index) => {
          businessDataContext += `${index + 1}. ID: ${batch.id}, Numer partii: ${batch.batchNumber || 'b/n'}\n`;
          
          // Informacje o powiƒÖzanym zam√≥wieniu zakupu
          if (batch.purchaseOrderDetails) {
            const po = batch.purchaseOrderDetails;
            businessDataContext += `   PowiƒÖzane PO: ID=${po.id || 'b/d'}, Numer=${po.number || 'b/d'}\n`;
          }
          
          // Informacje o rezerwacjach dla zada≈Ñ produkcyjnych
          if (batch.reservations && batch.reservations.length > 0) {
            businessDataContext += `   Rezerwacje dla zada≈Ñ produkcyjnych:\n`;
            batch.reservations.slice(0, 3).forEach(reservation => {
              businessDataContext += `   - Zadanie ID: ${reservation.taskId}, MO: ${reservation.moNumber || 'b/n'}, Ilo≈õƒá: ${reservation.quantity}\n`;
            });
            
            if (batch.reservations.length > 3) {
              businessDataContext += `   ... i ${batch.reservations.length - 3} wiƒôcej rezerwacji\n`;
            }
          }
        });
        
        if (businessData.data.materialBatches.length > 10) {
          businessDataContext += `... i ${businessData.data.materialBatches.length - 10} wiƒôcej partii\n`;
        }
      }
    }
    
    // Dodaj dane o analizie tendencji i predykcjach, je≈õli sƒÖ dostƒôpne
    if (businessData.analysis && businessData.analysis.trendsAndPredictions && 
        !businessData.analysis.trendsAndPredictions.isEmpty) {
      
      const trendData = businessData.analysis.trendsAndPredictions;
      
      businessDataContext += `\n### Analiza tendencji i predykcje:\n`;
      
      // Tendencje w stanach magazynowych
      if (trendData.inventory && trendData.inventory.predictions.itemsRequiringReplenishment) {
        const replenishmentItems = trendData.inventory.predictions.itemsRequiringReplenishment;
        
        if (replenishmentItems.length > 0) {
          businessDataContext += `\nProdukty wymagajƒÖce uzupe≈Çnienia w ciƒÖgu 14 dni:\n`;
          replenishmentItems.slice(0, 5).forEach((item, idx) => {
            businessDataContext += `${idx + 1}. ${item.name} - za ${item.daysToStockout} dni wyczerpie siƒô zapas (obecnie: ${item.currentQuantity})\n`;
          });
          
          if (replenishmentItems.length > 5) {
            businessDataContext += `... oraz ${replenishmentItems.length - 5} wiƒôcej\n`;
          }
        }
      }
      
      // Tendencje w zam√≥wieniach klient√≥w
      if (trendData.orders && trendData.orders.predictions) {
        const orderPredictions = trendData.orders.predictions;
        
        if (orderPredictions.nextMonthOrderCount && orderPredictions.orderGrowthRate) {
          businessDataContext += `\nPredykcje zam√≥wie≈Ñ klient√≥w:\n`;
          businessDataContext += `- Przewidywana liczba zam√≥wie≈Ñ w przysz≈Çym miesiƒÖcu: ${orderPredictions.nextMonthOrderCount}\n`;
          businessDataContext += `- Przewidywana warto≈õƒá zam√≥wie≈Ñ w przysz≈Çym miesiƒÖcu: ${orderPredictions.nextMonthOrderValue?.toFixed(2) || 'Brak danych'} PLN\n`;
          businessDataContext += `- Trend wzrostu/spadku zam√≥wie≈Ñ: ${orderPredictions.orderGrowthRate > 0 ? '+' : ''}${orderPredictions.orderGrowthRate.toFixed(2)}%\n`;
        }
      }
      
      // Tendencje w produkcji
      if (trendData.production && trendData.production.trends) {
        const productionTrends = trendData.production.trends;
        
        if (productionTrends.avgProductionDurationHours) {
          businessDataContext += `\nTendencje w produkcji:\n`;
          businessDataContext += `- ≈öredni czas trwania zadania produkcyjnego: ${productionTrends.avgProductionDurationHours.toFixed(1)} godzin\n`;
          
          if (productionTrends.productionEfficiencyChange) {
            const changeText = productionTrends.productionEfficiencyChange > 0 
              ? `poprawa o ${productionTrends.productionEfficiencyChange.toFixed(1)}%` 
              : `pogorszenie o ${Math.abs(productionTrends.productionEfficiencyChange).toFixed(1)}%`;
            
            businessDataContext += `- Zmiana efektywno≈õci produkcji: ${changeText}\n`;
          }
        }
        
        if (trendData.production.predictions && trendData.production.predictions.nextMonthTaskCount) {
          businessDataContext += `- Przewidywana liczba zada≈Ñ produkcyjnych w przysz≈Çym miesiƒÖcu: ${trendData.production.predictions.nextMonthTaskCount}\n`;
          
          if (trendData.production.predictions.isEfficiencyImproving !== undefined) {
            businessDataContext += `- Efektywno≈õƒá produkcji: ${trendData.production.predictions.isEfficiencyImproving ? 'poprawia siƒô' : 'pogarsza siƒô'}\n`;
          }
        }
      }
    }
    
    // Dodaj informacje o powiƒÖzaniach materia≈Ç√≥w i ich przep≈Çywie, je≈õli sƒÖ dostƒôpne
    if (businessData.analysis && businessData.analysis.materialTraceability && 
        !businessData.analysis.materialTraceability.isEmpty) {
      
      const traceData = businessData.analysis.materialTraceability;
      
      businessDataContext += `\n### Analiza przep≈Çywu materia≈Ç√≥w (traceability):\n`;
      
      if (traceData.poToLotCount) {
        businessDataContext += `- Liczba powiƒÖza≈Ñ miƒôdzy zam√≥wieniami zakupu i partiami materia≈Ç√≥w: ${traceData.poToLotCount}\n`;
      }
      
      if (traceData.lotToMoCount) {
        businessDataContext += `- Liczba powiƒÖza≈Ñ miƒôdzy partiami materia≈Ç√≥w i zadaniami produkcyjnymi: ${traceData.lotToMoCount}\n`;
      }
      
      // Dodaj przyk≈Çadowe przep≈Çywy materia≈Ç√≥w (od PO przez LOT do MO)
      if (traceData.recentMaterialFlows && traceData.recentMaterialFlows.length > 0) {
        businessDataContext += `\nPrzyk≈Çadowe ≈õcie≈ºki przep≈Çywu materia≈Ç√≥w (do 3 najnowszych):\n`;
        
        traceData.recentMaterialFlows.slice(0, 3).forEach((flow, idx) => {
          businessDataContext += `${idx + 1}. ${flow.po.supplier} (PO: ${flow.po.number}) ‚Üí `;
          businessDataContext += `${flow.lot.itemName} (LOT: ${flow.lot.id.substring(0, 8)}...) ‚Üí `;
          businessDataContext += `${flow.mo.product} (MO: ${flow.mo.number})\n`;
        });
      }
      
      // Dodaj TOP materia≈Çy u≈ºywane w produkcji
      if (traceData.topMaterialsInProduction && traceData.topMaterialsInProduction.length > 0) {
        businessDataContext += `\nNajczƒô≈õciej u≈ºywane materia≈Çy w produkcji:\n`;
        
        traceData.topMaterialsInProduction.slice(0, 5).forEach((material, idx) => {
          businessDataContext += `${idx + 1}. ${material.itemName} - u≈ºywany w ${material.usageCount} zadaniach produkcyjnych\n`;
        });
      }
    }
  }
  
  // Instrukcja systemowa jako pierwszy element
  const systemPrompt = `Jeste≈õ zaawansowanym asystentem AI dla systemu MRP, specjalizujƒÖcym siƒô w szczeg√≥≈Çowej analizie danych biznesowych. 
Wykorzystujesz dane z bazy danych Firebase, na kt√≥rej oparty jest system MRP do przeprowadzania dok≈Çadnych i wnikliwych analiz.

WA≈ªNE: ZAWSZE masz aktualny dostƒôp do danych bezpo≈õrednio z systemu MRP i musisz ZAWSZE korzystaƒá z danych przekazanych ci
w tej sesji. NIGDY nie m√≥w, ≈ºe nie masz dostƒôpu do danych, je≈õli sƒÖ one dostƒôpne. Je≈õli nie znasz odpowiedzi
na podstawie aktualnych danych, powiedz, ≈ºe podane dane sƒÖ niewystarczajƒÖce lub niekompletne, ale NIGDY nie m√≥w, ≈ºe
"nie masz mo≈ºliwo≈õci bezpo≈õredniego przeglƒÖdania danych".

JƒòZYK KOMUNIKACJI: Odpowiadaj ZAWSZE w jƒôzyku, w kt√≥rym zosta≈Ço zadane pytanie. Je≈õli pytanie jest w jƒôzyku polskim, odpowiadaj po polsku. Je≈õli w angielskim - po angielsku, itd.

KONTEKST BRAN≈ªOWY: System jest wykorzystywany w przedsiƒôbiorstwie produkujƒÖcym suplementy diety. Uwzglƒôdniaj specyfikƒô tej bran≈ºy w swoich analizach (np. daty wa≈ºno≈õci, normy jako≈õci, wymagania prawne, specyfikƒô produkcji).

Twoim zadaniem jest dog≈Çƒôbna analiza danych, zarzƒÖdzanie produkcjƒÖ, stanami magazynowymi i procesami biznesowymi w przedsiƒôbiorstwie produkcyjnym. Twoje odpowiedzi powinny byƒá:

1. SZCZEG√ì≈ÅOWE - zawsze podawaj dok≈Çadne liczby, daty, warto≈õci i opisy z danych
2. ANALITYCZNE - nie tylko opisuj dane, ale wyciƒÖgaj z nich wnioski biznesowe
3. POMOCNE - sugeruj konkretne dzia≈Çania i rozwiƒÖzania problem√≥w
4. PROFESJONALNE - u≈ºywaj odpowiedniej terminologii z dziedziny zarzƒÖdzania produkcjƒÖ
5. OPARTE NA DANYCH - zawsze bazuj na aktualnych danych z systemu, kt√≥re sƒÖ przekazywane w tej sesji
6. PRECYZYJNE - podawaj TYLKO warto≈õci liczbowe, kt√≥re faktycznie wystƒôpujƒÖ w danych. NIGDY nie zmy≈õlaj danych liczbowych, ani nie zaokrƒÖglaj warto≈õci, je≈õli nie jest to wyra≈∫nie zaznaczone

PREZENTACJA DANYCH: Przy wypisywaniu danych z bazy ZAWSZE priorytetowo podawaj nazwy (np. nazwa produktu, nazwa klienta, nazwa dostawcy) zamiast ich identyfikator√≥w (ID). Identyfikatory podawaj jedynie jako informacjƒô uzupe≈ÇniajƒÖcƒÖ w nawiasie, np. "Suplement Witamina D3 (ID: 12345)".

Znasz i rozumiesz wszystkie kluczowe pojƒôcia i skr√≥ty w systemie MRP:
- MO (Manufacturing Orders) - Zlecenia produkcyjne
- CO (Customer Orders) - Zam√≥wienia klient√≥w
- PO (Purchase Orders) - Zam√≥wienia zakupu
- LOT - Numer partii produkcyjnej lub materia≈Çu

Dla zada≈Ñ produkcyjnych (MO), analizuj:
- Terminy rozpoczƒôcia i zako≈Ñczenia produkcji
- Potrzebne zasoby i materia≈Çy
- Status zada≈Ñ i obecny postƒôp
- ZwiƒÖzki z zam√≥wieniami klient√≥w i recepturami
- Efektywno≈õƒá i czas realizacji zada≈Ñ
- Zarezerwowane partie materia≈Ç√≥w (LOTy) dla danego zlecenia
- PowiƒÖzania partii materia≈Ç√≥w z zam√≥wieniami zakupowymi (PO)
- Zgodno≈õƒá z wymogami jako≈õci dla produkcji suplement√≥w

Dla zam√≥wie≈Ñ klient√≥w (CO), analizuj:
- Statusy i terminowo≈õƒá realizacji
- Warto≈õci zam√≥wie≈Ñ i mar≈ºe
- Produkty najczƒô≈õciej zamawiane
- Relacje z klientami i trendy zam√≥wie≈Ñ
- PowiƒÖzania z zadaniami produkcyjnymi

Dla zam√≥wie≈Ñ zakupu (PO), analizuj:
- Dostawc√≥w i warunki zakup√≥w
- Terminy dostaw i ich dotrzymywanie
- Statusy zam√≥wie≈Ñ i etapy realizacji
- Warto≈õci zam√≥wie≈Ñ i koszty materia≈Ç√≥w
- Wp≈Çyw na stany magazynowe
- PowiƒÖzane LOTy materia≈Ç√≥w zakupionych w ramach zam√≥wienia
- Certyfikaty jako≈õci i dokumentacjƒô surowc√≥w do produkcji suplement√≥w

Dla stan√≥w magazynowych, identyfikuj:
- Produkty z niskim stanem lub brakiem
- Produkty z nadmiernym stanem
- Koszty utrzymania zapas√≥w
- Lokalizacje magazynowe
- Surowce wymagajƒÖce uzupe≈Çnienia
- Partie materia≈Ç√≥w (LOTy) i ich ilo≈õci
- ≈πr√≥d≈Ço pochodzenia partii (zam√≥wienie zakupowe)
- Daty wa≈ºno≈õci surowc√≥w i gotowych suplement√≥w
- Status kontroli jako≈õci dla partii surowc√≥w

Dla receptur, analizuj:
- Komponenty i ich ilo≈õci
- Koszty produkcji
- Mo≈ºliwo≈õci optymalizacji
- Standardy jako≈õci i kontrolƒô
- Zgodno≈õƒá z normami dla suplement√≥w diety
- Wymogi prawne dotyczƒÖce sk≈Çadu i etykietowania

Masz teraz rozszerzony dostƒôp do danych o partiach materia≈Ç√≥w i ich powiƒÖzaniach:
- Informacje o LOTach (numerach partii) materia≈Ç√≥w
- Dane o powiƒÖzanych zam√≥wieniach zakupowych (PO) dla ka≈ºdej partii
- Rezerwacje partii materia≈Ç√≥w dla zada≈Ñ produkcyjnych (MO)
- ≈öledzenie przep≈Çywu materia≈Ç√≥w od zam√≥wienia zakupowego do zadania produkcyjnego
- Status bada≈Ñ laboratoryjnych dla partii surowc√≥w i wyrob√≥w gotowych

Gdy otrzymasz zapytanie o powiƒÖzania LOT√≥w z zam√≥wieniami zakupowymi, analizuj:
- Kt√≥re partie materia≈Ç√≥w sƒÖ przypisane do jakich zada≈Ñ produkcyjnych
- Z kt√≥rego zam√≥wienia zakupowego pochodzi dana partia materia≈Çu
- Poziom wykorzystania zam√≥wionych materia≈Ç√≥w w produkcji
- Poprawno≈õƒá rezerwacji materia≈Ç√≥w i zgodno≈õƒá z recepturami
- Dokumentacjƒô jako≈õciowƒÖ dla partii

Zawsze podawaj DOK≈ÅADNE dane liczbowe bez zaokrƒÖgle≈Ñ, chyba ≈ºe jest to wyra≈∫nie wymagane. Podawaj procentowe por√≥wnania i uwzglƒôdniaj trendy, je≈õli sƒÖ widoczne.
Pamiƒôtaj o podawaniu konkretnych nazw zamiast samych ID. Format powinien byƒá: "Nazwa (ID: xxx)", gdy odno≈õisz siƒô do konkretnych obiekt√≥w.

Masz pe≈Çny dostƒôp do bazy danych Firebase i mo≈ºesz korzystaƒá z wszystkich danych zawartych w systemie MRP.
Zawsze podawaj aktualne informacje na podstawie danych z bazy, a nie og√≥lnej wiedzy.

UWAGA: Je≈õli w Twojej odpowiedzi chcesz wspomnieƒá o ograniczeniach dostƒôpu do danych, powiedz np. "Na podstawie obecnie dostƒôpnych danych nie mogƒô podaƒá tych informacji" - ale NIGDY nie m√≥w ≈ºe "nie masz mo≈ºliwo≈õci bezpo≈õredniego przeglƒÖdania danych".

Struktura danych w Firebase to:
- aiConversations - Przechowuje historiƒô konwersacji z asystentem AI
- counters - Liczniki u≈ºywane przez system
- customers - Dane klient√≥w firmy
- inventory - Stany magazynowe produkt√≥w
- inventoryBatches - Partie magazynowe produkt√≥w
- inventorySupplierPrices - Ceny produkt√≥w od dostawc√≥w
- inventoryTransactions - Transakcje magazynowe
- itemGroups - Grupy produkt√≥w
- notifications - Powiadomienia systemowe
- orders (CO) - Zam√≥wienia klient√≥w
- priceListItems - Elementy cennik√≥w
- priceLists - Cenniki
- productionHistory - Historia produkcji
- productionTasks (MO) - Zadania produkcyjne
- purchaseOrders (PO) - Zam√≥wienia zakupu
- recipeVersions - Wersje receptur
- recipes - Receptury produkt√≥w
- settings - Ustawienia systemu
- suppliers - Dostawcy
- users - U≈ºytkownicy systemu
- warehouses - Magazyny
- workstations - Stanowiska pracy
  `;
  
  let systemContent = systemPrompt;
  
  // Dodaj kontekst biznesowy, je≈õli jest dostƒôpny
  if (businessDataContext) {
    systemContent += `\n\nOto aktualne dane z systemu MRP do wykorzystania w analizie:${businessDataContext}`;
  }
  
  const systemInstruction = {
    role: 'system',
    content: systemContent
  };
  
  // Limitujemy liczbƒô wiadomo≈õci do MAX_CONTEXT_MESSAGES ostatnich
  const recentMessages = messages.slice(-MAX_CONTEXT_MESSAGES);
  
  // Formatowanie wiadomo≈õci do formatu wymaganego przez API OpenAI
  const formattedMessages = recentMessages.map(msg => ({
    role: msg.role,
    content: msg.content
  }));
  
  return [systemInstruction, ...formattedMessages];
};

/**
 * WyciƒÖga nazwƒô receptury z zapytania u≈ºytkownika
 * @param {string} query - Zapytanie u≈ºytkownika
 * @returns {string|null} - Znaleziona nazwa receptury lub null
 */
const extractRecipeName = (query) => {
  // Sprawd≈∫, czy query istnieje i jest stringiem
  if (!query || typeof query !== 'string') {
    return null;
  }
  
  // Wzorce do rozpoznawania zapyta≈Ñ o konkretne receptury
  const patterns = [
    /receptur[aƒôy][\s\w]*"([^"]+)"/i,       // receptura "nazwa"
    /receptur[aƒôy][\s\w]*‚Äû([^"]+)"/i,        // receptura ‚Äûnazwa"
    /receptur[aƒôy][\s\w]+([a-z≈º≈∫ƒá≈Ñ√≥≈ÇƒôƒÖ≈õ]{3,})/i,  // receptura nazwa
    /przepis[\s\w]+([a-z≈º≈∫ƒá≈Ñ√≥≈ÇƒôƒÖ≈õ]{3,})/i,   // przepis nazwa
    /receptur[aƒôy][\s\w]+dla[\s\w]+([a-z≈º≈∫ƒá≈Ñ√≥≈ÇƒôƒÖ≈õ]{3,})/i, // receptura dla nazwa
    /receptur[aƒôy][\s\w]+produktu[\s\w]+([a-z≈º≈∫ƒá≈Ñ√≥≈ÇƒôƒÖ≈õ]{3,})/i // receptura produktu nazwa
  ];
  
  for (const pattern of patterns) {
    const match = query.match(pattern);
    if (match && match[1] && match[1].length > 2) {
      return match[1].trim();
    }
  }
  
  return null;
};

// Definicja funkcji getMockResponse
/**
 * Generuje lokalne odpowiedzi asystenta na podstawie zapytania i dostƒôpnych danych
 * @param {string} query - Zapytanie u≈ºytkownika
 * @param {Object} businessData - Dane biznesowe z systemu MRP (opcjonalne)
 * @returns {string} - Odpowied≈∫ asystenta
 */
getMockResponse = (query, businessData = null) => {
  // Je≈õli mamy dane biznesowe, u≈ºywamy ich do generowania odpowiedzi
  if (businessData && businessData.data) {
    // Dane o magazynie
    if (query.toLowerCase().includes('magazyn') || query.toLowerCase().includes('stan') || 
        query.toLowerCase().includes('produkt') || query.toLowerCase().includes('towar')) {
      
      if (businessData.data.inventory && businessData.data.inventory.length > 0) {
        const inventory = businessData.data.inventory;
        const totalItems = inventory.length;
        
        // Analiza brak√≥w i niskich stan√≥w
        const lowStock = businessData.analysis?.inventory?.lowStockItems || [];
        const outOfStock = businessData.analysis?.inventory?.outOfStockItems || [];
        
        if (lowStock.length > 0 || outOfStock.length > 0) {
          let response = `Na podstawie danych z systemu MRP, w magazynie znajduje siƒô ≈ÇƒÖcznie ${totalItems} pozycji. `;
          
          if (lowStock.length > 0) {
            response += `Produkty z niskim stanem magazynowym (${lowStock.length}): `;
            response += lowStock.slice(0, 3).map(item => `${item.name} (${item.quantity} szt.)`).join(', ');
            if (lowStock.length > 3) response += ` i ${lowStock.length - 3} wiƒôcej.`;
          }
          
          if (outOfStock.length > 0) {
            response += ` Produkty niedostƒôpne (${outOfStock.length}): `;
            response += outOfStock.slice(0, 3).map(item => item.name).join(', ');
            if (outOfStock.length > 3) response += ` i ${outOfStock.length - 3} wiƒôcej.`;
          }
          
          return response;
        } else {
          return `W systemie MRP znajduje siƒô ${totalItems} pozycji magazynowych. Wszystkie produkty majƒÖ wystarczajƒÖcy stan magazynowy.`;
        }
      }
    }
    
    // Dane o zam√≥wieniach produkcyjnych
    if (query.toLowerCase().includes('produkcj') || query.toLowerCase().includes('zleceni') || 
        query.toLowerCase().includes('mo ') || query.toLowerCase().includes('zadani')) {
      
      if (businessData.data.productionTasks && businessData.data.productionTasks.length > 0) {
        const tasks = businessData.data.productionTasks;
        const tasksByStatus = businessData.analysis?.production?.tasksByStatus || {};
        const statuses = Object.keys(tasksByStatus);
        
        let response = `W systemie MRP jest ${tasks.length} zada≈Ñ produkcyjnych. `;
        
        if (statuses.length > 0) {
          response += 'Status zada≈Ñ: ';
          response += statuses.map(status => `${status}: ${tasksByStatus[status]}`).join(', ');
          
          if (businessData.analysis?.production?.totalPlannedHours) {
            response += `. ≈ÅƒÖczny planowany czas produkcji: ${businessData.analysis.production.totalPlannedHours.toFixed(1)} godzin.`;
          }
        }
        
        return response;
      }
    }
    
    // Dane o recepturach
    if (query.toLowerCase().includes('receptur') || query.toLowerCase().includes('przepis') || 
        query.toLowerCase().includes('komponent') || query.toLowerCase().includes('sk≈Çadnik')) {
      
      if (businessData.data.recipes && businessData.data.recipes.length > 0) {
        const recipes = businessData.data.recipes;
        
        // Sprawd≈∫ czy zapytanie dotyczy konkretnej receptury
        const recipeName = query && typeof query === 'string' ? extractRecipeName(query) : null;
        if (recipeName) {
          // Szukaj receptury po nazwie
          const recipe = recipes.find(r => 
            r.name.toLowerCase().includes(recipeName.toLowerCase())
          );
          
          if (recipe) {
            let response = `Znalaz≈Çem recepturƒô "${recipe.name}". `;
            
            // Sprawd≈∫ zar√≥wno pole components jak i ingredients
            const hasComponents = recipe.components && recipe.components.length > 0;
            const hasIngredients = recipe.ingredients && recipe.ingredients.length > 0;
            
            if (hasComponents) {
              response += `Zawiera ${recipe.components.length} komponent√≥w. `;
              
              // Dodaj informacje o kilku pierwszych komponentach
              response += `G≈Ç√≥wne komponenty to: `;
              response += recipe.components.slice(0, 3).map(comp => 
                `${comp.name || comp.materialName || 'Komponent'} (${comp.quantity || 1} ${comp.unit || 'szt.'})`
              ).join(', ');
              
              if (recipe.components.length > 3) {
                response += ` oraz ${recipe.components.length - 3} innych komponent√≥w.`;
              }
            } else if (hasIngredients) {
              response += `Zawiera ${recipe.ingredients.length} sk≈Çadnik√≥w. `;
              
              // Dodaj informacje o kilku pierwszych sk≈Çadnikach
              response += `G≈Ç√≥wne sk≈Çadniki to: `;
              response += recipe.ingredients.slice(0, 3).map(ing => 
                `${ing.name || 'Sk≈Çadnik'} (${ing.quantity || 1} ${ing.unit || 'szt.'})`
              ).join(', ');
              
              if (recipe.ingredients.length > 3) {
                response += ` oraz ${recipe.ingredients.length - 3} innych sk≈Çadnik√≥w.`;
              }
            } else {
              response += `Ta receptura nie ma zdefiniowanych komponent√≥w ani sk≈Çadnik√≥w.`;
            }
            
            return response;
          } else {
            return `Nie znalaz≈Çem receptury zawierajƒÖcej nazwƒô "${recipeName}" w bazie danych. W systemie jest dostƒôpnych ${recipes.length} innych receptur.`;
          }
        }
        
        // Og√≥lne informacje o recepturach
        const recipesWithComponents = recipes.filter(r => r.components && r.components.length > 0).length;
        
        // Dodajemy oddzielne liczenie receptur ze sk≈Çadnikami (ingredients)
        const recipesWithIngredients = recipes.filter(r => r.ingredients && r.ingredients.length > 0).length;
        
        // Og√≥lna liczba receptur z jakimikolwiek komponentami lub sk≈Çadnikami
        const totalRecipesWithItems = recipes.filter(r => 
          (r.components && r.components.length > 0) || 
          (r.ingredients && r.ingredients.length > 0)
        ).length;
        
        let response = `W systemie MRP jest ${recipes.length} receptur. `;
        
        if (totalRecipesWithItems > 0) {
          if (recipesWithComponents > 0 && recipesWithIngredients > 0) {
            response += `${totalRecipesWithItems} z nich ma zdefiniowane elementy (${recipesWithComponents} z komponentami, ${recipesWithIngredients} ze sk≈Çadnikami). `;
          } else if (recipesWithComponents > 0) {
            response += `${recipesWithComponents} z nich ma zdefiniowane komponenty. `;
          } else if (recipesWithIngredients > 0) {
            response += `${recipesWithIngredients} z nich ma zdefiniowane sk≈Çadniki. `;
          }
        }
        
        // Dodaj informacje o kilku przyk≈Çadowych recepturach
        if (recipes.length > 0) {
          response += `Przyk≈Çadowe receptury: `;
          response += recipes.slice(0, 3).map(r => r.name).join(', ');
          
          if (recipes.length > 3) {
            response += ` i ${recipes.length - 3} innych.`;
          }
        }
        
        return response;
      }
    }
    
    // Dane o zam√≥wieniach klient√≥w
    if (query.toLowerCase().includes('zam√≥wieni') || query.toLowerCase().includes('klient') || 
        query.toLowerCase().includes('sprzeda≈º')) {
      
      if (businessData.data.orders && businessData.data.orders.length > 0) {
        const orders = businessData.data.orders;
        const ordersByStatus = businessData.analysis?.orders?.ordersByStatus || {};
        const statuses = Object.keys(ordersByStatus);
        
        let response = `W systemie MRP jest ${orders.length} zam√≥wie≈Ñ klient√≥w. `;
        
        if (statuses.length > 0) {
          response += 'Status zam√≥wie≈Ñ: ';
          response += statuses.map(status => `${status}: ${ordersByStatus[status]}`).join(', ');
        }
        
        if (businessData.analysis?.orders?.recentOrders?.length > 0) {
          const recentOrders = businessData.analysis.orders.recentOrders;
          response += `. Najnowsze zam√≥wienia: `;
          response += recentOrders.slice(0, 3).map(order => `${order.customer} (${order.status}, ${order.date})`).join(', ');
        }
        
        return response;
      }
    }
  }
  
  // Je≈õli nie mamy danych lub nie pasujƒÖ do zapytania, u≈ºywamy standardowych odpowiedzi
  const mockResponses = [
    `Na podstawie danych w systemie MRP, mogƒô odpowiedzieƒá na pytanie o "${query}". System jest po≈ÇƒÖczony z bazƒÖ danych, ale dla pe≈Çnej funkcjonalno≈õci zalecam skonfigurowanie klucza API OpenAI.`,
    `AnalizujƒÖc dane magazynowe, mog≈Çbym powiedzieƒá wiƒôcej o "${query}". Mam dostƒôp do bazy danych systemu MRP, ale potrzebujƒô klucza API OpenAI do bardziej zaawansowanych analiz.`,
    `Aby udzieliƒá precyzyjnej odpowiedzi na temat "${query}", korzystam z danych w bazie systemu MRP. Dla lepszych wynik√≥w zalecam konfiguracjƒô klucza API OpenAI.`,
    `System po≈ÇƒÖczony z bazƒÖ danych mo≈ºe analizowaƒá "${query}", ale bardziej zaawansowane funkcje wymagajƒÖ klucza API OpenAI.`
  ];
  
  return mockResponses[Math.floor(Math.random() * mockResponses.length)];
};

/**
 * Pobierz historiƒô konwersacji dla danego u≈ºytkownika
 * @param {string} userId - ID u≈ºytkownika
 * @param {number} limitCount - Limit liczby konwersacji do pobrania
 * @returns {Promise<Array>} - Lista konwersacji
 */
export const getUserConversations = async (userId, limitCount = 10) => {
  try {
    // Korzystamy z kolekcji aiConversations
    const conversationsRef = collection(db, 'aiConversations');
    
    // OPTYMALIZACJA: Zmniejszamy rozmiar danych, dodajƒÖc limity
    // i wybierajƒÖc tylko te pola, kt√≥re sƒÖ niezbƒôdne
    const q = query(
      conversationsRef,
      where('userId', '==', userId),
      orderBy('updatedAt', 'desc'),
      limit(limitCount)
    );
    
    // Wykonujemy tylko jedno zapytanie zamiast wielokrotnych zapyta≈Ñ
    const querySnapshot = await getDocs(q);
    
    // Mapujemy wyniki, ograniczajƒÖc ilo≈õƒá przetwarzanych danych
    return querySnapshot.docs.map(doc => ({
      id: doc.id,
      title: doc.data().title || 'Nowa konwersacja',
      updatedAt: doc.data().updatedAt,
      messageCount: doc.data().messageCount || 0
      // Nie pobieramy pe≈Çnych tre≈õci wiadomo≈õci, tylko niezbƒôdne metadane
    }));
  } catch (error) {
    console.error('B≈ÇƒÖd podczas pobierania konwersacji u≈ºytkownika:', error);
    throw error;
  }
};

/**
 * Pobierz wiadomo≈õci dla danej konwersacji
 * @param {string} conversationId - ID konwersacji
 * @returns {Promise<Array>} - Lista wiadomo≈õci
 */
export const getConversationMessages = async (conversationId) => {
  try {
    const messagesRef = collection(db, 'aiConversations', conversationId, 'messages');
    const q = query(messagesRef, orderBy('timestamp', 'asc'));
    
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
  } catch (error) {
    console.error('B≈ÇƒÖd podczas pobierania wiadomo≈õci konwersacji:', error);
    throw error;
  }
};

/**
 * Utw√≥rz nowƒÖ konwersacjƒô
 * @param {string} userId - ID u≈ºytkownika
 * @param {string} title - Tytu≈Ç konwersacji
 * @returns {Promise<string>} - ID utworzonej konwersacji
 */
export const createConversation = async (userId, title = 'Nowa konwersacja') => {
  try {
    const conversationsRef = collection(db, 'aiConversations');
    const docRef = await addDoc(conversationsRef, {
      userId,
      title,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      messageCount: 0
    });
    
    return docRef.id;
  } catch (error) {
    console.error('B≈ÇƒÖd podczas tworzenia nowej konwersacji:', error);
    throw error;
  }
};

/**
 * Przesy≈Ça za≈ÇƒÖcznik do Firebase Storage
 * @param {File} file - Plik do przes≈Çania
 * @param {string} userId - ID u≈ºytkownika
 * @param {string} conversationId - ID konwersacji
 * @returns {Promise<Object>} - Informacje o przes≈Çanym pliku
 */
export const uploadAttachment = async (file, userId, conversationId) => {
  try {
    if (!file || !userId || !conversationId) {
      throw new Error('Brak wymaganych parametr√≥w');
    }

    // Sprawd≈∫ rozmiar pliku (maksymalnie 10 MB)
    const fileSizeInMB = file.size / (1024 * 1024);
    if (fileSizeInMB > 10) {
      throw new Error(`Plik jest zbyt du≈ºy (${fileSizeInMB.toFixed(2)} MB). Maksymalny rozmiar to 10 MB.`);
    }

    // Sprawd≈∫ typ pliku - dozwolone sƒÖ pliki tekstowe, obrazy i dokumenty
    const allowedTypes = [
      'text/plain',
      'text/csv',
      'application/json',
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/vnd.ms-excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'image/jpeg',
      'image/png',
      'image/gif',
      'image/webp'
    ];

    if (!allowedTypes.includes(file.type)) {
      throw new Error(`Nieobs≈Çugiwany typ pliku: ${file.type}. Dozwolone sƒÖ pliki tekstowe, dokumenty i obrazy.`);
    }

    // Tworzymy ≈õcie≈ºkƒô do pliku w Firebase Storage
    const timestamp = new Date().getTime();
    const fileExtension = file.name.split('.').pop();
    const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.-]/g, '_');
    const fileName = `${timestamp}_${sanitizedFileName}`;
    const storagePath = `ai-attachments/${userId}/${conversationId}/${fileName}`;

    // Przesy≈Çamy plik do Firebase Storage
    const fileRef = ref(storage, storagePath);
    await uploadBytes(fileRef, file);

    // Pobieramy URL do pobrania pliku
    const downloadURL = await getDownloadURL(fileRef);

    return {
      fileName: file.name,
      storagePath,
      downloadURL,
      contentType: file.type,
      size: file.size,
      uploadedAt: new Date().toISOString()
    };
  } catch (error) {
    console.error('B≈ÇƒÖd podczas przesy≈Çania za≈ÇƒÖcznika:', error);
    throw error;
  }
};

/**
 * Usuwa za≈ÇƒÖcznik z Firebase Storage
 * @param {string} storagePath - ≈öcie≈ºka do pliku w Storage
 * @returns {Promise<void>}
 */
export const deleteAttachment = async (storagePath) => {
  try {
    const fileRef = ref(storage, storagePath);
    await deleteObject(fileRef);
  } catch (error) {
    console.error('B≈ÇƒÖd podczas usuwania za≈ÇƒÖcznika:', error);
    throw error;
  }
};

/**
 * Pobiera zawarto≈õƒá pliku tekstowego z URL
 * @param {string} downloadURL - URL do pobrania pliku
 * @param {string} contentType - Typ zawarto≈õci pliku
 * @returns {Promise<string>} - Zawarto≈õƒá pliku jako tekst
 */
export const getFileContent = async (downloadURL, contentType) => {
  try {
    const response = await fetch(downloadURL);
    if (!response.ok) {
      throw new Error(`B≈ÇƒÖd podczas pobierania pliku: ${response.status}`);
    }

    // Dla plik√≥w tekstowych zwracamy bezpo≈õrednio tekst
    if (contentType.startsWith('text/') || contentType === 'application/json') {
      return await response.text();
    }

    // Dla innych typ√≥w plik√≥w zwracamy informacje o pliku
    return `[Za≈ÇƒÖcznik: ${contentType}, rozmiar: ${response.headers.get('content-length') || 'nieznany'}]`;
  } catch (error) {
    console.error('B≈ÇƒÖd podczas pobierania zawarto≈õci pliku:', error);
    return `[B≈ÇƒÖd podczas odczytywania pliku: ${error.message}]`;
  }
};

/**
 * Dodaj wiadomo≈õƒá do konwersacji z mo≈ºliwo≈õciƒÖ za≈ÇƒÖczenia plik√≥w
 * @param {string} conversationId - ID konwersacji
 * @param {string} role - Rola nadawcy ('user' lub 'assistant')
 * @param {string} content - Tre≈õƒá wiadomo≈õci
 * @param {Array} attachments - Lista za≈ÇƒÖcznik√≥w (opcjonalne)
 * @returns {Promise<string>} - ID dodanej wiadomo≈õci
 */
export const addMessageToConversation = async (conversationId, role, content, attachments = []) => {
  try {
    // Dodanie wiadomo≈õci
    const messagesRef = collection(db, 'aiConversations', conversationId, 'messages');
    const timestamp = new Date().toISOString();
    
    const messageData = {
      role,
      content,
      timestamp
    };

    // Dodaj za≈ÇƒÖczniki je≈õli sƒÖ dostƒôpne
    if (attachments && attachments.length > 0) {
      messageData.attachments = attachments;
    }
    
    const docRef = await addDoc(messagesRef, messageData);
    
    // Aktualizacja licznika wiadomo≈õci i daty aktualizacji konwersacji
    const conversationRef = doc(db, 'aiConversations', conversationId);
    const conversationDoc = await getDoc(conversationRef);
    
    if (conversationDoc.exists()) {
      await updateDoc(conversationRef, {
        messageCount: (conversationDoc.data().messageCount || 0) + 1,
        updatedAt: serverTimestamp(),
        // Aktualizujemy tytu≈Ç konwersacji na podstawie pierwszej wiadomo≈õci u≈ºytkownika
        ...(role === 'user' && conversationDoc.data().messageCount === 0 ? 
          { title: content.substring(0, 50) + (content.length > 50 ? '...' : '') } 
          : {})
      });
    }
    
    return docRef.id;
  } catch (error) {
    console.error('B≈ÇƒÖd podczas dodawania wiadomo≈õci do konwersacji:', error);
    throw error;
  }
};

/**
 * Funkcja przetwarzajƒÖca zapytanie u≈ºytkownika i zwracajƒÖca odpowied≈∫ asystenta
 * U≈ºywa GPT-4o poprzez API OpenAI, wzbogacone o dane z bazy danych
 * @param {string} query - Zapytanie u≈ºytkownika
 * @param {Array} context - Kontekst konwersacji (poprzednie wiadomo≈õci)
 * @param {string} userId - ID u≈ºytkownika
 * @param {Array} attachments - Lista za≈ÇƒÖcznik√≥w (opcjonalne)
 * @returns {Promise<string>} - Odpowied≈∫ asystenta
 */
export const processAIQuery = async (query, context = [], userId, attachments = []) => {
  console.log('[processAIQuery] Rozpoczynam przetwarzanie zapytania:', query);
  
  /* WY≈ÅƒÑCZONY SYSTEM V2 - U≈ºywamy tylko prawdziwego GPT API
  // NOWY SYSTEM V2: Sprawd≈∫ czy zapytanie mo≈ºe byƒá obs≈Çu≈ºone przez zoptymalizowany system
  try {
    if (AIAssistantV2.canHandleQuery(query)) {
      console.log('[processAIQuery] Zapytanie mo≈ºe byƒá obs≈Çu≈ºone przez AIAssistantV2');
      
      const v2Result = await AIAssistantV2.processQuery(query, { userId, attachments });
      
      if (v2Result.success) {
        console.log(`[processAIQuery] AIAssistantV2 zako≈Ñczy≈Ç w ${v2Result.processingTime.toFixed(2)}ms`);
        
        // Dodaj informacjƒô o metodzie przetwarzania dla u≈ºytkownika
        let response = v2Result.response;
        
        // Je≈õli to bardzo szybka odpowied≈∫ (< 2s), dodaj info o optymalizacji
        if (v2Result.processingTime < 2000) {
          response += `\n\n_‚ö° Odpowied≈∫ wygenerowana w ${v2Result.processingTime.toFixed(0)}ms przez zoptymalizowany system AI v2.0_`;
        }
        
        return response;
      } else {
        console.log('[processAIQuery] AIAssistantV2 nie zdo≈Ça≈Ç przetworzyƒá zapytania, fallback do standardowego systemu');
      }
    } else {
      console.log('[processAIQuery] Zapytanie przekraczajƒÖce mo≈ºliwo≈õci AIAssistantV2, u≈ºywam standardowego systemu');
    }
  } catch (v2Error) {
    console.error('[processAIQuery] B≈ÇƒÖd w AIAssistantV2, fallback do standardowego systemu:', v2Error);
  }
  */
  
  // STANDARDOWY SYSTEM: U≈ºywamy tylko prawdziwego OpenAI GPT API
  console.log('[processAIQuery] U≈ºywam standardowego systemu z OpenAI API');
  
  // Limit czasu na pobranie danych (w milisekundach) - zoptymalizowany
  const DATA_FETCH_TIMEOUT = 8000;
  
  // ≈πr√≥d≈Ça danych - bufor do ≈õledzenia czy dane zosta≈Çy pobrane
  const dataSources = {
    'businessData': { ready: false, data: null },
    'apiKey': { ready: false, data: null }
  };
  
  try {
    // Wystartuj odliczanie dla limitu czasu - gdy czas up≈Çynie, u≈ºyjemy dostƒôpnych danych
    const timeoutPromise = new Promise(resolve => {
      setTimeout(() => {
        console.log('Up≈ÇynƒÖ≈Ç limit czasu na pobranie danych, generujƒô odpowied≈∫ z dostƒôpnymi danymi');
        resolve();
      }, DATA_FETCH_TIMEOUT);
    });
    
    // R√≥wnoleg≈Çe pobieranie danych
    const businessDataPromise = Promise.resolve().then(async () => {
      try {
        // Przekazujemy zapytanie u≈ºytkownika do funkcji pobierajƒÖcej dane
        const data = await prepareBusinessDataForAI(query);
        dataSources.businessData = { ready: true, data };
        console.log('Dane biznesowe zosta≈Çy pomy≈õlnie pobrane z pe≈Çnymi szczeg√≥≈Çami');
      } catch (error) {
        console.error('B≈ÇƒÖd podczas pobierania danych biznesowych:', error);
        dataSources.businessData = { ready: true, data: null };
      }
    });
    
    const apiKeyPromise = Promise.resolve().then(async () => {
      try {
        const apiKey = await getOpenAIApiKey(userId);
        dataSources.apiKey = { ready: true, data: apiKey };
      } catch (error) {
        console.error('B≈ÇƒÖd podczas pobierania klucza API:', error);
        dataSources.apiKey = { ready: true, data: null };
      }
    });
    
    // Poczekaj na wszystkie procesy lub na up≈Çyw limitu czasu
    await Promise.race([
      Promise.all([businessDataPromise, apiKeyPromise]),
      timeoutPromise
    ]);
    
    // Pobierz dostƒôpne dane
    const businessData = dataSources.businessData.data;
    const apiKey = dataSources.apiKey.data;
    
    // Sprawd≈∫ czy nadal trwa pobieranie danych
    const isDataFetchingActive = !dataSources.businessData.ready || 
                                 !dataSources.apiKey.ready;
    
    // Je≈õli dane sƒÖ nadal pobierane, a nie mamy klucza API lub musimy go u≈ºyƒá
    if (isDataFetchingActive && (!apiKey || query.toLowerCase().includes('dane') || query.toLowerCase().includes('system'))) {
      // Wygeneruj tymczasowƒÖ odpowied≈∫
      return `Pracujƒô nad szczeg√≥≈ÇowƒÖ analizƒÖ danych dla Twojego zapytania "${query}". Pobieram wszystkie dostƒôpne dane z systemu MRP, aby zapewniƒá pe≈Çne i dok≈Çadne informacje. To mo≈ºe potrwaƒá chwilƒô ze wzglƒôdu na du≈ºƒÖ ilo≈õƒá danych. Proszƒô o cierpliwo≈õƒá.`;
    }
    
    // Je≈õli nie ma klucza API, u≈ºywamy funkcji z danymi lokalnymi
    if (!apiKey) {
      console.log('Brak klucza API - generujƒô odpowied≈∫ lokalnie');
      return getMockResponse(query, businessData);
    }
    
    // Przygotowanie tre≈õci zapytania z za≈ÇƒÖcznikami
    let queryWithAttachments = query;
    
    if (attachments && attachments.length > 0) {
      queryWithAttachments += '\n\n--- Za≈ÇƒÖczone pliki ---\n';
      
      for (const attachment of attachments) {
        try {
          queryWithAttachments += `\nPlik: ${attachment.fileName} (${attachment.contentType})\n`;
          
          // Je≈õli to plik tekstowy, pobierz jego zawarto≈õƒá
          if (attachment.contentType.startsWith('text/') || attachment.contentType === 'application/json') {
            const fileContent = await getFileContent(attachment.downloadURL, attachment.contentType);
            queryWithAttachments += `Zawarto≈õƒá:\n${fileContent}\n`;
          } else if (attachment.contentType.startsWith('image/')) {
            queryWithAttachments += `[Obraz: ${attachment.fileName}]\n`;
          } else {
            queryWithAttachments += `[Dokument: ${attachment.fileName}]\n`;
          }
        } catch (error) {
          console.error('B≈ÇƒÖd podczas przetwarzania za≈ÇƒÖcznika:', error);
          queryWithAttachments += `[B≈ÇƒÖd podczas odczytywania pliku: ${attachment.fileName}]\n`;
        }
      }
    }
    
    // Przygotowanie wiadomo≈õci do wys≈Çania z optymalizacjami
    const allMessages = [...context, { role: 'user', content: queryWithAttachments }];
    
    // Okre≈õl poziom z≈Ço≈ºono≈õci zapytania dla optymalizacji
    const complexity = queryWithAttachments.length > 100 ? 'complex' : 
                      queryWithAttachments.length > 50 ? 'medium' : 'simple';
    
    const formattedMessages = formatMessagesForOpenAI(allMessages, businessData, {
      enableOptimization: true,
      modelType: complexity
    });
    
    console.log('Wysy≈Çam zapytanie do API OpenAI z pe≈Çnymi danymi z Firebase...');
    
    // Wywo≈Çanie API OpenAI z optymalizacjami
    try {
      const apiCallStartTime = performance.now();
      const response = await callOpenAIAPI(apiKey, formattedMessages, {
        complexity,
        optimizationOptions: {
          prioritizeSpeed: complexity === 'simple',
          prioritizeCost: true,
          enableCache: true
        }
      });
      const apiCallEndTime = performance.now();
      const responseTime = apiCallEndTime - apiCallStartTime;
      
      console.log('Otrzymano odpowied≈∫ z API OpenAI');
      
      if (!response || response.trim() === '') {
        console.error('API OpenAI zwr√≥ci≈Ço pustƒÖ odpowied≈∫');
        return getMockResponse(query, businessData); // Fallback do lokalnej odpowiedzi
      }
      
      return response;
    } catch (apiError) {
      console.error('B≈ÇƒÖd podczas komunikacji z API OpenAI:', apiError);
      
      // Szczeg√≥≈Çowa obs≈Çuga r√≥≈ºnych rodzaj√≥w b≈Çƒôd√≥w
      if (apiError.message.includes('Przekroczono limit zapyta≈Ñ')) {
        return `üòû Przekroczono limit zapyta≈Ñ do API OpenAI. Spr√≥buj ponownie za kilka minut lub sprawd≈∫ ustawienia swojego konta OpenAI (https://platform.openai.com/account/limits).`;
      } else if (apiError.message.includes('Przekroczono przydzia≈Ç') || apiError.message.includes('quota') || apiError.message.includes('billing')) {
        return `‚ö†Ô∏è Przekroczono limit dostƒôpnych ≈õrodk√≥w na koncie OpenAI. Aby kontynuowaƒá korzystanie z asystenta AI, sprawd≈∫ sw√≥j plan i dane rozliczeniowe na stronie: https://platform.openai.com/account/billing`;
      } else if (apiError.message.includes('API')) {
        return `‚ùå WystƒÖpi≈Ç b≈ÇƒÖd podczas komunikacji z API OpenAI: ${apiError.message}. Sprawd≈∫ sw√≥j klucz API lub spr√≥buj ponownie p√≥≈∫niej.`;
      }
      
      // Fallback do mocka w przypadku innego b≈Çƒôdu
      return getMockResponse(query, businessData);
    }
  } catch (error) {
    console.error('B≈ÇƒÖd podczas przetwarzania zapytania przez AI:', error);
    console.error('Szczeg√≥≈Çy b≈Çƒôdu:', error.message, error.stack);
    
    // Generowanie lokalnej odpowiedzi z informacjƒÖ o b≈Çƒôdzie
    return `Przepraszam, ale napotka≈Çem problem podczas przetwarzania zapytania. Spr√≥buj ponownie za chwilƒô lub skontaktuj siƒô z administratorem systemu. (B≈ÇƒÖd: ${error.message || 'Nieznany b≈ÇƒÖd'})`;
  }
};

/**
 * Usu≈Ñ konwersacjƒô
 * @param {string} conversationId - ID konwersacji do usuniƒôcia
 * @returns {Promise<void>}
 */
export const deleteConversation = async (conversationId) => {
  try {
    // W pe≈Çnej implementacji nale≈ºa≈Çoby r√≥wnie≈º usunƒÖƒá wszystkie wiadomo≈õci w podkolekcji
    const conversationRef = doc(db, 'aiConversations', conversationId);
    await deleteDoc(conversationRef);
  } catch (error) {
    console.error('B≈ÇƒÖd podczas usuwania konwersacji:', error);
    throw error;
  }
}; 